// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title DatatypesStorageSolution
 * @notice Reference contract that shows how value/reference types live in storage and how to interact with them.
 * @dev Syntax-first walkthrough: mappings, arrays, structs, and data locations. See README for the deep CS explanations.
 */
contract DatatypesStorageSolution {
    // TYPE DEFINITIONS (no storage used until instantiated)
    struct User {
        address wallet;
        uint256 balance;
        bool isRegistered;
    }

    // Packed to highlight slot sharing (2 slots instead of 3+)—compare with unpacked User above.
    struct PackedData {
        uint128 smallNumber1;
        uint128 smallNumber2;
        address user;
        uint64 timestamp;
        bool flag;
    }

    // STATE
    uint256 public number; // Slot 0: EVM-native width keeps arithmetic cheap.
    address public owner; // Slot 1: ownership pattern reused in Project 04.
    bool public isActive; // Slot 2: tiny type still consumes a full slot.
    bytes32 public data; // Slot 3: fixed-size hashes/IDs.
    string public message; // Slot 4+: dynamic data demonstrates expensive storage.

    mapping(address => uint256) public balances; // Slot 5: keccak(key, slot) layout from Project 01 theory section.
    uint256[] public numbers; // Slot 6: length in slot, elements at keccak(slot)+i.
    mapping(address => User) public users; // Nested structs laid out sequentially from computed base slot.

    // EVENTS (cheap history vs storage writes)
    event NumberUpdated(uint256 indexed oldValue, uint256 indexed newValue);
    event UserRegistered(address indexed wallet, uint256 balance);
    event FundsDeposited(address indexed depositor, uint256 amount);
    event MessageUpdated(string oldMessage, string newMessage);
    event BalanceUpdated(address addr, uint256 balance);

    constructor() {
        owner = msg.sender; // One-time slot write; mirrors access-control lesson later.
        isActive = true;
    }

    // ETHER HANDLING ---------------------------------------------------------
    function deposit() public payable {
        require(msg.value > 0, "Deposit amount must be greater than 0");
        balances[msg.sender] += msg.value; // Read-modify-write: shows storage cost vs memory.
        emit FundsDeposited(msg.sender, msg.value);
    }

    // VALUE TYPES ------------------------------------------------------------
    function setNumber(uint256 _number) public {
        uint256 oldValue = number; // Cache to avoid double SLOAD when emitting.
        number = _number;
        emit NumberUpdated(oldValue, _number);
    }

    function getNumber() public view returns (uint256) {
        return number; // Mirrors autogenerated getter; kept for explicit syntax practice.
    }

    function incrementNumber() public {
        number += 1; // Solidity 0.8+ auto-reverts on overflow.
    }

    function setMessage(string memory _message) public {
        string memory oldMessage = message; // Storage→memory copy avoids second read.
        message = _message;
        emit MessageUpdated(oldMessage, _message);
    }

    // MAPPINGS ---------------------------------------------------------------
    function setBalance(address _address, uint256 _balance) public {
        balances[_address] = _balance; // Direct assignment avoids extra read when overwriting.
        emit BalanceUpdated(_address, _balance);
    }

    function getBalance(address _address) public view returns (uint256) {
        return balances[_address]; // Unset keys return 0 (mapping default).
    }

    // ARRAYS -----------------------------------------------------------------
    function addNumber(uint256 _number) public {
        numbers.push(_number); // Two writes: length + element at computed slot.
    }

    function getNumbersLength() public view returns (uint256) {
        return numbers.length;
    }

    function getNumberAt(uint256 _index) public view returns (uint256) {
        require(_index < numbers.length, "Index out of bounds");
        return numbers[_index];
    }

    function removeNumber(uint256 _index) public {
        require(_index < numbers.length, "Index out of bounds");
        uint256 lastIndex = numbers.length - 1;
        numbers[_index] = numbers[lastIndex]; // Swap & pop keeps O(1) gas, loses ordering.
        numbers.pop();
    }

    // STRUCTS ----------------------------------------------------------------
    function registerUser(address _wallet, uint256 _balance) public {
        users[_wallet] = User({wallet: _wallet, balance: _balance, isRegistered: true});
        emit UserRegistered(_wallet, _balance);
    }

    function getUser(address _wallet)
        public
        view
        returns (address wallet, uint256 balance, bool isRegistered)
    {
        User memory user = users[_wallet]; // Copy to memory before returning multiple values.
        return (user.wallet, user.balance, user.isRegistered);
    }

    // DATA LOCATIONS ---------------------------------------------------------
    function sumMemoryArray(uint256[] memory _arr) public pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < _arr.length; i++) {
            sum += _arr[i]; // Memory reads are cheap; no persistence.
        }
        return sum;
    }

    function getFirstElement(uint256[] calldata _arr) public pure returns (uint256) {
        require(_arr.length > 0, "Array is empty");
        return _arr[0]; // Calldata is zero-copy; only valid in external functions.
    }

    // ════════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS - Utility Operations
    // ════════════════════════════════════════════════════════════════════════
    
    /**
     * @notice Check if address has a balance
     * @dev BOOLEAN LOGIC (Computer Science: Predicate Functions)
     * 
     * Simple predicate function that returns true/false.
     * 
     * MAPPING DEFAULT VALUES:
     * - Unset keys return 0 (zero value)
     * - balances[_address] returns 0 if never set
     * - 0 > 0 evaluates to false
     * 
     * SYNTAX: return balances[_address] > 0;
     * - Comparison operator: > (greater than)
     * - Returns bool (true or false)
     */
    function hasBalance(address _address) public view returns (bool) {
        // Check if balance is greater than zero
        // Unset mapping keys return 0, so this works correctly
        return balances[_address] > 0; // SLOAD + comparison: ~103 gas (warm)
    }

    /**
     * @notice Example of packed struct in memory
     * @dev STRUCT PACKING DEMONSTRATION
     * 
     * This function creates a packed struct in memory to demonstrate
     * the packing concept (though packing only saves gas in storage).
     * 
     * BLOCK PROPERTIES:
     * - block.timestamp: Current block timestamp (Unix epoch)
     * - Available in all functions
     * - Set by miner/validator
     * 
     * TYPE CASTING:
     * - uint64(block.timestamp): Casts uint256 to uint64
     * - May truncate if timestamp > 2^64 - 1 (unlikely before year 2262)
     * 
     * SYNTAX: PackedData memory example = PackedData({...});
     * - Creates struct instance in memory
     * - Named parameter syntax for clarity
     * - Memory structs don't benefit from packing (only storage does)
     */
    function getPackedDataExample()
        public
        view
        returns (uint128, uint128, uint64, address, bool)
    {
        // Create struct in memory (packing doesn't save gas here, only in storage)
        PackedData memory example = PackedData({
            smallNumber1: 100,
            smallNumber2: 200,
            timestamp: uint64(block.timestamp), // Type casting: uint256 → uint64
            user: address(0x1234567890123456789012345678901234567890),
            flag: true
        });

        // Return struct fields
        return (example.smallNumber1, example.smallNumber2, example.timestamp, example.user, example.flag);
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════
 *                          KEY TAKEAWAYS - PROJECT 01
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * 1. STORAGE LAYOUT IS FUNDAMENTAL
 *    ✅ Each contract has 2^256 storage slots
 *    ✅ Value types stored directly in slots
 *    ✅ Reference types use computed slots
 *    ✅ Understanding layout = gas optimization
 * 
 * 2. DATA LOCATIONS MATTER
 *    ✅ storage: Persistent, expensive (~20k gas per write)
 *    ✅ memory: Temporary, cheaper (~3 gas per read)
 *    ✅ calldata: Zero-copy, read-only (most efficient!)
 * 
 * 3. MAPPINGS = HASH TABLES
 *    ✅ O(1) lookup time (average case)
 *    ✅ Storage slot = keccak256(key, base_slot)
 *    ✅ Perfect for key-value lookups
 *    ✅ No iteration capability
 * 
 * 4. ARRAYS = DYNAMIC ARRAYS
 *    ✅ O(1) indexed access
 *    ✅ O(n) iteration/search
 *    ✅ Length stored in base slot
 *    ✅ Elements at keccak256(slot) + index
 * 
 * 5. STRUCTS = COMPOSITE TYPES
 *    ✅ Group related data together
 *    ✅ Fields stored sequentially
 *    ✅ Packing saves gas (multiple small types in one slot)
 * 
 * 6. STORAGE IS EXPENSIVE
 *    ✅ Write: ~20,000 gas (zero to non-zero)
 *    ✅ Read: ~100 gas (warm) or ~2,100 gas (cold)
 *    ✅ Cache values you use multiple times!
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 *                    CONNECTIONS TO FUTURE PROJECTS
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * • Project 02: Functions & Payable
 *   - Learn function visibility (public, external, internal, private)
 *   - Understand payable functions and ETH handling
 *   - Build on storage patterns from Project 01
 * 
 * • Project 03: Events & Logging
 *   - Events are cheaper than storage for historical data
 *   - Indexed parameters enable efficient filtering
 *   - Essential for off-chain indexing
 * 
 * • Project 04: Modifiers & Restrictions
 *   - Access control using owner pattern (from Project 01)
 *   - Custom modifiers for code reuse
 *   - Pause functionality
 * 
 * • Project 06: Mappings, Arrays & Gas
 *   - Deep dive into gas optimization
 *   - When to use mappings vs arrays
 *   - Running totals pattern
 * 
 * • Project 08: ERC20 Token
 *   - Uses mappings for balances (from Project 01)
 *   - Uses events for transfers (from Project 03)
 *   - Combines all concepts into real-world token
 * 
 * ═══════════════════════════════════════════════════════════════════════════
 *                        COMPUTER SCIENCE CONCEPTS
 * ═══════════════════════════════════════════════════════════════════════════
 * 
 * • Hash Tables: Mappings are hash tables with O(1) average-case operations
 * • Dynamic Arrays: Arrays provide O(1) access but O(n) search
 * • Memory Management: Understanding storage vs memory vs calldata
 * • Data Structures: Choosing the right structure for the problem
 * • Big-Endian Storage: EVM stores values in big-endian format
 * • Storage Packing: Optimizing storage layout to save gas
 * 
 * Master these concepts - they're the foundation for everything else!
 */
