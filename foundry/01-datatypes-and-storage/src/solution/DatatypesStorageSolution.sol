// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title DatatypesStorageSolution
 * @notice Reference contract that shows how value/reference types live in storage and how to interact with them.
 * @dev Syntax-first walkthrough: mappings, arrays, structs, and data locations. See README for the deep CS explanations.
 */
contract DatatypesStorageSolution {
    // TYPE DEFINITIONS (no storage used until instantiated)
    struct User {
        address wallet;
        uint256 balance;
        bool isRegistered;
    }

    // Packed to highlight slot sharing (2 slots instead of 3+)—compare with unpacked User above.
    struct PackedData {
        uint128 smallNumber1;
        uint128 smallNumber2;
        address user;
        uint64 timestamp;
        bool flag;
    }

    // STATE
    uint256 public number; // Slot 0: EVM-native width keeps arithmetic cheap.
    address public owner; // Slot 1: ownership pattern reused in Project 04.
    bool public isActive; // Slot 2: tiny type still consumes a full slot.
    bytes32 public data; // Slot 3: fixed-size hashes/IDs.
    string public message; // Slot 4+: dynamic data demonstrates expensive storage.

    mapping(address => uint256) public balances; // Slot 5: keccak(key, slot) layout from Project 01 theory section.
    uint256[] public numbers; // Slot 6: length in slot, elements at keccak(slot)+i.
    mapping(address => User) public users; // Nested structs laid out sequentially from computed base slot.

    // EVENTS (cheap history vs storage writes)
    event NumberUpdated(uint256 indexed oldValue, uint256 indexed newValue);
    event UserRegistered(address indexed wallet, uint256 balance);
    event FundsDeposited(address indexed depositor, uint256 amount);
    event MessageUpdated(string oldMessage, string newMessage);
    event BalanceUpdated(address addr, uint256 balance);

    constructor() {
        owner = msg.sender; // One-time slot write; mirrors access-control lesson later.
        isActive = true;
    }

    // ETHER HANDLING ---------------------------------------------------------
    function deposit() public payable {
        require(msg.value > 0, "Deposit amount must be greater than 0");
        balances[msg.sender] += msg.value; // Read-modify-write: shows storage cost vs memory.
        emit FundsDeposited(msg.sender, msg.value);
    }

    // VALUE TYPES ------------------------------------------------------------
    function setNumber(uint256 _number) public {
        uint256 oldValue = number; // Cache to avoid double SLOAD when emitting.
        number = _number;
        emit NumberUpdated(oldValue, _number);
    }

    function getNumber() public view returns (uint256) {
        return number; // Mirrors autogenerated getter; kept for explicit syntax practice.
    }

    function incrementNumber() public {
        number += 1; // Solidity 0.8+ auto-reverts on overflow.
    }

    function setMessage(string memory _message) public {
        string memory oldMessage = message; // Storage→memory copy avoids second read.
        message = _message;
        emit MessageUpdated(oldMessage, _message);
    }

    // MAPPINGS ---------------------------------------------------------------
    function setBalance(address _address, uint256 _balance) public {
        balances[_address] = _balance; // Direct assignment avoids extra read when overwriting.
        emit BalanceUpdated(_address, _balance);
    }

    function getBalance(address _address) public view returns (uint256) {
        return balances[_address]; // Unset keys return 0 (mapping default).
    }

    // ARRAYS -----------------------------------------------------------------
    function addNumber(uint256 _number) public {
        numbers.push(_number); // Two writes: length + element at computed slot.
    }

    function getNumbersLength() public view returns (uint256) {
        return numbers.length;
    }

    function getNumberAt(uint256 _index) public view returns (uint256) {
        require(_index < numbers.length, "Index out of bounds");
        return numbers[_index];
    }

    function removeNumber(uint256 _index) public {
        require(_index < numbers.length, "Index out of bounds");
        uint256 lastIndex = numbers.length - 1;
        numbers[_index] = numbers[lastIndex]; // Swap & pop keeps O(1) gas, loses ordering.
        numbers.pop();
    }

    // STRUCTS ----------------------------------------------------------------
    function registerUser(address _wallet, uint256 _balance) public {
        users[_wallet] = User({wallet: _wallet, balance: _balance, isRegistered: true});
        emit UserRegistered(_wallet, _balance);
    }

    function getUser(address _wallet)
        public
        view
        returns (address wallet, uint256 balance, bool isRegistered)
    {
        User memory user = users[_wallet]; // Copy to memory before returning multiple values.
        return (user.wallet, user.balance, user.isRegistered);
    }

    // DATA LOCATIONS ---------------------------------------------------------
    function sumMemoryArray(uint256[] memory _arr) public pure returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < _arr.length; i++) {
            sum += _arr[i]; // Memory reads are cheap; no persistence.
        }
        return sum;
    }

    function getFirstElement(uint256[] calldata _arr) public pure returns (uint256) {
        require(_arr.length > 0, "Array is empty");
        return _arr[0]; // Calldata is zero-copy; only valid in external functions.
    }

    // HELPERS ----------------------------------------------------------------
    function hasBalance(address _address) public view returns (bool) {
        return balances[_address] > 0;
    }

    function getPackedDataExample()
        public
        view
        returns (uint128, uint128, uint64, address, bool)
    {
        PackedData memory example = PackedData({
            smallNumber1: 100,
            smallNumber2: 200,
            timestamp: uint64(block.timestamp),
            user: address(0x1234567890123456789012345678901234567890),
            flag: true
        });

        return (example.smallNumber1, example.smallNumber2, example.timestamp, example.user, example.flag);
    }
}
