{"abi":[{"type":"constructor","inputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"addNumber","inputs":[{"name":"_number","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"balances","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"data","inputs":[],"outputs":[{"name":"","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"deposit","inputs":[],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"getBalance","inputs":[{"name":"_address","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getFirstElement","inputs":[{"name":"_arr","type":"uint256[]","internalType":"uint256[]"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getNumber","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getNumberAt","inputs":[{"name":"_index","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getNumbersLength","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getPackedDataExample","inputs":[],"outputs":[{"name":"","type":"uint128","internalType":"uint128"},{"name":"","type":"uint128","internalType":"uint128"},{"name":"","type":"uint64","internalType":"uint64"},{"name":"","type":"address","internalType":"address"},{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"getUser","inputs":[{"name":"_wallet","type":"address","internalType":"address"}],"outputs":[{"name":"wallet","type":"address","internalType":"address"},{"name":"balance","type":"uint256","internalType":"uint256"},{"name":"isRegistered","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"hasBalance","inputs":[{"name":"_address","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"incrementNumber","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"isActive","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"message","inputs":[],"outputs":[{"name":"","type":"string","internalType":"string"}],"stateMutability":"view"},{"type":"function","name":"number","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"numbers","inputs":[{"name":"","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"registerUser","inputs":[{"name":"_wallet","type":"address","internalType":"address"},{"name":"_balance","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"removeNumber","inputs":[{"name":"_index","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setBalance","inputs":[{"name":"_address","type":"address","internalType":"address"},{"name":"_balance","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setMessage","inputs":[{"name":"_message","type":"string","internalType":"string"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setNumber","inputs":[{"name":"_number","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"sumMemoryArray","inputs":[{"name":"_arr","type":"uint256[]","internalType":"uint256[]"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"users","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"wallet","type":"address","internalType":"address"},{"name":"balance","type":"uint256","internalType":"uint256"},{"name":"isRegistered","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"event","name":"BalanceUpdated","inputs":[{"name":"addr","type":"address","indexed":false,"internalType":"address"},{"name":"balance","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"FundsDeposited","inputs":[{"name":"depositor","type":"address","indexed":true,"internalType":"address"},{"name":"amount","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"MessageUpdated","inputs":[{"name":"oldMessage","type":"string","indexed":false,"internalType":"string"},{"name":"newMessage","type":"string","indexed":false,"internalType":"string"}],"anonymous":false},{"type":"event","name":"NumberUpdated","inputs":[{"name":"oldValue","type":"uint256","indexed":true,"internalType":"uint256"},{"name":"newValue","type":"uint256","indexed":true,"internalType":"uint256"}],"anonymous":false},{"type":"event","name":"UserRegistered","inputs":[{"name":"wallet","type":"address","indexed":true,"internalType":"address"},{"name":"balance","type":"uint256","indexed":false,"internalType":"uint256"}],"anonymous":false}],"bytecode":{"object":"0x608060405234801561000f575f80fd5b506001805460ff60a01b1933166001600160a81b031990911617600160a01b179055610fe78061003e5f395ff3fe608060405260043610610161575f3560e01c80638da5cb5b116100cd578063e30443bc11610087578063f3d4e56211610062578063f3d4e56214610510578063f8b2cb4f14610524578063fa0b5e5514610558578063fce6802314610577575f80fd5b8063e30443bc146104bf578063eea54fb6146104de578063f2c9ecd8146104fd575f80fd5b80638da5cb5b146103da578063a87430ba14610411578063d0e30db014610458578063d39fa23314610460578063e16633a41461047f578063e21f37ce1461049e575f80fd5b806346b71fff1161011e57806346b71fff1461025d5780634be581311461027c5780636f77926b1461030157806373d4a13a146103925780638381f58a146103a75780638af79949146103bb575f80fd5b806322b2678a1461016557806322f3e2d4146101b0578063273ea3e3146101d057806327e235e3146101e6578063368b87721461021f5780633fb5c1cb1461023e575b5f80fd5b348015610170575f80fd5b5061019b61017f366004610b30565b6001600160a01b03165f90815260046020526040902054151590565b60405190151581526020015b60405180910390f35b3480156101bb575f80fd5b5060015461019b90600160a01b900460ff1681565b3480156101db575f80fd5b506101e46105c5565b005b3480156101f1575f80fd5b50610211610200366004610b30565b60046020525f908152604090205481565b6040519081526020016101a7565b34801561022a575f80fd5b506101e4610239366004610b95565b6105dd565b348015610249575f80fd5b506101e4610258366004610c24565b6106b6565b348015610268575f80fd5b50610211610277366004610c3b565b6106ec565b348015610287575f80fd5b506040805160a08082018352606480835260c860208085018290527312345678901234567890123456789012345678908587018190524267ffffffffffffffff16606080880182905260016080988901819052895196875293860194909452968401969096529082019490945291820192909252016101a7565b34801561030c575f80fd5b5061036b61031b366004610b30565b6001600160a01b038082165f9081526006602090815260409182902082516060810184528154909416808552600182015492850183905260029091015460ff161515939092018390529093909250565b604080516001600160a01b03909416845260208401929092521515908201526060016101a7565b34801561039d575f80fd5b5061021160025481565b3480156103b2575f80fd5b506102115f5481565b3480156103c6575f80fd5b506102116103d5366004610c24565b610752565b3480156103e5575f80fd5b506001546103f9906001600160a01b031681565b6040516001600160a01b0390911681526020016101a7565b34801561041c575f80fd5b5061036b61042b366004610b30565b60066020525f90815260409020805460018201546002909201546001600160a01b03909116919060ff1683565b6101e46107be565b34801561046b575f80fd5b5061021161047a366004610c24565b610875565b34801561048a575f80fd5b50610211610499366004610caa565b610894565b3480156104a9575f80fd5b506104b26108e1565b6040516101a79190610d8e565b3480156104ca575f80fd5b506101e46104d9366004610da0565b61096d565b3480156104e9575f80fd5b506101e46104f8366004610c24565b6109bd565b348015610508575f80fd5b505f54610211565b34801561051b575f80fd5b50600554610211565b34801561052f575f80fd5b5061021161053e366004610b30565b6001600160a01b03165f9081526004602052604090205490565b348015610563575f80fd5b506101e4610572366004610da0565b610a79565b348015610582575f80fd5b506101e4610591366004610c24565b600580546001810182555f919091527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00155565b60015f808282546105d69190610ddc565b9091555050565b5f600380546105eb90610def565b80601f016020809104026020016040519081016040528092919081815260200182805461061790610def565b80156106625780601f1061063957610100808354040283529160200191610662565b820191905f5260205f20905b81548152906001019060200180831161064557829003601f168201915b5050505050905081600390816106789190610e75565b507f5b4717af615de779c9c12885d202645882ad93995957a99a4a1a145b3ccdbc1081836040516106aa929190610f31565b60405180910390a15050565b5f80548282556040519091839183917f32853224b52c8c1c4c85ba01615b18e43506c8be20fcbb909a81ca220b3ee71f91a35050565b5f816107305760405162461bcd60e51b815260206004820152600e60248201526d417272617920697320656d70747960901b60448201526064015b60405180910390fd5b82825f81811061074257610742610f5e565b9050602002013590505b92915050565b6005545f90821061079b5760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b6044820152606401610727565b600582815481106107ae576107ae610f5e565b905f5260205f2001549050919050565b5f341161081b5760405162461bcd60e51b815260206004820152602560248201527f4465706f73697420616d6f756e74206d75737420626520677265617465722074604482015264068616e20360dc1b6064820152608401610727565b335f9081526004602052604081208054349290610839908490610ddc565b909155505060405134815233907f543ba50a5eec5e6178218e364b1d0f396157b3c8fa278522c2cb7fd99407d4749060200160405180910390a2565b60058181548110610884575f80fd5b5f91825260209091200154905081565b5f80805b83518110156108da578381815181106108b3576108b3610f5e565b6020026020010151826108c69190610ddc565b9150806108d281610f72565b915050610898565b5092915050565b600380546108ee90610def565b80601f016020809104026020016040519081016040528092919081815260200182805461091a90610def565b80156109655780601f1061093c57610100808354040283529160200191610965565b820191905f5260205f20905b81548152906001019060200180831161094857829003601f168201915b505050505081565b6001600160a01b0382165f81815260046020908152604091829020849055815192835282018390527f8ad64a0ac7700dd8425ab0499f107cb6e2cd1581d803c5b8c1c79dcb8190b1af91016106aa565b6005548110610a045760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b6044820152606401610727565b6005545f90610a1590600190610f8a565b905060058181548110610a2a57610a2a610f5e565b905f5260205f20015460058381548110610a4657610a46610f5e565b5f918252602090912001556005805480610a6257610a62610f9d565b600190038181905f5260205f20015f905590555050565b604080516060810182526001600160a01b03848116808352602080840186815260018587018181525f85815260068552889020965187546001600160a01b031916961695909517865590519085015591516002909301805460ff191693151593909317909255915183815290917fe29d35093005f4d575e1003753426b57a7f64378ba73332eef9c6ccc2b8decd6910160405180910390a25050565b80356001600160a01b0381168114610b2b575f80fd5b919050565b5f60208284031215610b40575f80fd5b610b4982610b15565b9392505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610b8d57610b8d610b50565b604052919050565b5f6020808385031215610ba6575f80fd5b823567ffffffffffffffff80821115610bbd575f80fd5b818501915085601f830112610bd0575f80fd5b813581811115610be257610be2610b50565b610bf4601f8201601f19168501610b64565b91508082528684828501011115610c09575f80fd5b80848401858401375f90820190930192909252509392505050565b5f60208284031215610c34575f80fd5b5035919050565b5f8060208385031215610c4c575f80fd5b823567ffffffffffffffff80821115610c63575f80fd5b818501915085601f830112610c76575f80fd5b813581811115610c84575f80fd5b8660208260051b8501011115610c98575f80fd5b60209290920196919550909350505050565b5f6020808385031215610cbb575f80fd5b823567ffffffffffffffff80821115610cd2575f80fd5b818501915085601f830112610ce5575f80fd5b813581811115610cf757610cf7610b50565b8060051b9150610d08848301610b64565b8181529183018401918481019088841115610d21575f80fd5b938501935b83851015610d3f57843582529385019390850190610d26565b98975050505050505050565b5f81518084525f5b81811015610d6f57602081850181015186830182015201610d53565b505f602082860101526020601f19601f83011685010191505092915050565b602081525f610b496020830184610d4b565b5f8060408385031215610db1575f80fd5b610dba83610b15565b946020939093013593505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561074c5761074c610dc8565b600181811c90821680610e0357607f821691505b602082108103610e2157634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610e70575f81815260208120601f850160051c81016020861015610e4d5750805b601f850160051c820191505b81811015610e6c57828155600101610e59565b5050505b505050565b815167ffffffffffffffff811115610e8f57610e8f610b50565b610ea381610e9d8454610def565b84610e27565b602080601f831160018114610ed6575f8415610ebf5750858301515b5f19600386901b1c1916600185901b178555610e6c565b5f85815260208120601f198616915b82811015610f0457888601518255948401946001909101908401610ee5565b5085821015610f2157878501515f19600388901b60f8161c191681555b5050505050600190811b01905550565b604081525f610f436040830185610d4b565b8281036020840152610f558185610d4b565b95945050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60018201610f8357610f83610dc8565b5060010190565b8181038181111561074c5761074c610dc8565b634e487b7160e01b5f52603160045260245ffdfea26469706673582212203bdd908e340cfe2ced40d47d5fa4475b337c74052844dd856204288eaed5e46164736f6c63430008140033","sourceMap":"3129:85750:38:-:0;;;20041:932;;;;;;;;;-1:-1:-1;20309:5:38;:18;;-1:-1:-1;;;;20317:10:38;20607:15;-1:-1:-1;;;;;;20607:15:38;;;;-1:-1:-1;;;20607:15:38;;;3129:85750;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x608060405260043610610161575f3560e01c80638da5cb5b116100cd578063e30443bc11610087578063f3d4e56211610062578063f3d4e56214610510578063f8b2cb4f14610524578063fa0b5e5514610558578063fce6802314610577575f80fd5b8063e30443bc146104bf578063eea54fb6146104de578063f2c9ecd8146104fd575f80fd5b80638da5cb5b146103da578063a87430ba14610411578063d0e30db014610458578063d39fa23314610460578063e16633a41461047f578063e21f37ce1461049e575f80fd5b806346b71fff1161011e57806346b71fff1461025d5780634be581311461027c5780636f77926b1461030157806373d4a13a146103925780638381f58a146103a75780638af79949146103bb575f80fd5b806322b2678a1461016557806322f3e2d4146101b0578063273ea3e3146101d057806327e235e3146101e6578063368b87721461021f5780633fb5c1cb1461023e575b5f80fd5b348015610170575f80fd5b5061019b61017f366004610b30565b6001600160a01b03165f90815260046020526040902054151590565b60405190151581526020015b60405180910390f35b3480156101bb575f80fd5b5060015461019b90600160a01b900460ff1681565b3480156101db575f80fd5b506101e46105c5565b005b3480156101f1575f80fd5b50610211610200366004610b30565b60046020525f908152604090205481565b6040519081526020016101a7565b34801561022a575f80fd5b506101e4610239366004610b95565b6105dd565b348015610249575f80fd5b506101e4610258366004610c24565b6106b6565b348015610268575f80fd5b50610211610277366004610c3b565b6106ec565b348015610287575f80fd5b506040805160a08082018352606480835260c860208085018290527312345678901234567890123456789012345678908587018190524267ffffffffffffffff16606080880182905260016080988901819052895196875293860194909452968401969096529082019490945291820192909252016101a7565b34801561030c575f80fd5b5061036b61031b366004610b30565b6001600160a01b038082165f9081526006602090815260409182902082516060810184528154909416808552600182015492850183905260029091015460ff161515939092018390529093909250565b604080516001600160a01b03909416845260208401929092521515908201526060016101a7565b34801561039d575f80fd5b5061021160025481565b3480156103b2575f80fd5b506102115f5481565b3480156103c6575f80fd5b506102116103d5366004610c24565b610752565b3480156103e5575f80fd5b506001546103f9906001600160a01b031681565b6040516001600160a01b0390911681526020016101a7565b34801561041c575f80fd5b5061036b61042b366004610b30565b60066020525f90815260409020805460018201546002909201546001600160a01b03909116919060ff1683565b6101e46107be565b34801561046b575f80fd5b5061021161047a366004610c24565b610875565b34801561048a575f80fd5b50610211610499366004610caa565b610894565b3480156104a9575f80fd5b506104b26108e1565b6040516101a79190610d8e565b3480156104ca575f80fd5b506101e46104d9366004610da0565b61096d565b3480156104e9575f80fd5b506101e46104f8366004610c24565b6109bd565b348015610508575f80fd5b505f54610211565b34801561051b575f80fd5b50600554610211565b34801561052f575f80fd5b5061021161053e366004610b30565b6001600160a01b03165f9081526004602052604090205490565b348015610563575f80fd5b506101e4610572366004610da0565b610a79565b348015610582575f80fd5b506101e4610591366004610c24565b600580546001810182555f919091527f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00155565b60015f808282546105d69190610ddc565b9091555050565b5f600380546105eb90610def565b80601f016020809104026020016040519081016040528092919081815260200182805461061790610def565b80156106625780601f1061063957610100808354040283529160200191610662565b820191905f5260205f20905b81548152906001019060200180831161064557829003601f168201915b5050505050905081600390816106789190610e75565b507f5b4717af615de779c9c12885d202645882ad93995957a99a4a1a145b3ccdbc1081836040516106aa929190610f31565b60405180910390a15050565b5f80548282556040519091839183917f32853224b52c8c1c4c85ba01615b18e43506c8be20fcbb909a81ca220b3ee71f91a35050565b5f816107305760405162461bcd60e51b815260206004820152600e60248201526d417272617920697320656d70747960901b60448201526064015b60405180910390fd5b82825f81811061074257610742610f5e565b9050602002013590505b92915050565b6005545f90821061079b5760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b6044820152606401610727565b600582815481106107ae576107ae610f5e565b905f5260205f2001549050919050565b5f341161081b5760405162461bcd60e51b815260206004820152602560248201527f4465706f73697420616d6f756e74206d75737420626520677265617465722074604482015264068616e20360dc1b6064820152608401610727565b335f9081526004602052604081208054349290610839908490610ddc565b909155505060405134815233907f543ba50a5eec5e6178218e364b1d0f396157b3c8fa278522c2cb7fd99407d4749060200160405180910390a2565b60058181548110610884575f80fd5b5f91825260209091200154905081565b5f80805b83518110156108da578381815181106108b3576108b3610f5e565b6020026020010151826108c69190610ddc565b9150806108d281610f72565b915050610898565b5092915050565b600380546108ee90610def565b80601f016020809104026020016040519081016040528092919081815260200182805461091a90610def565b80156109655780601f1061093c57610100808354040283529160200191610965565b820191905f5260205f20905b81548152906001019060200180831161094857829003601f168201915b505050505081565b6001600160a01b0382165f81815260046020908152604091829020849055815192835282018390527f8ad64a0ac7700dd8425ab0499f107cb6e2cd1581d803c5b8c1c79dcb8190b1af91016106aa565b6005548110610a045760405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b6044820152606401610727565b6005545f90610a1590600190610f8a565b905060058181548110610a2a57610a2a610f5e565b905f5260205f20015460058381548110610a4657610a46610f5e565b5f918252602090912001556005805480610a6257610a62610f9d565b600190038181905f5260205f20015f905590555050565b604080516060810182526001600160a01b03848116808352602080840186815260018587018181525f85815260068552889020965187546001600160a01b031916961695909517865590519085015591516002909301805460ff191693151593909317909255915183815290917fe29d35093005f4d575e1003753426b57a7f64378ba73332eef9c6ccc2b8decd6910160405180910390a25050565b80356001600160a01b0381168114610b2b575f80fd5b919050565b5f60208284031215610b40575f80fd5b610b4982610b15565b9392505050565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f1916810167ffffffffffffffff81118282101715610b8d57610b8d610b50565b604052919050565b5f6020808385031215610ba6575f80fd5b823567ffffffffffffffff80821115610bbd575f80fd5b818501915085601f830112610bd0575f80fd5b813581811115610be257610be2610b50565b610bf4601f8201601f19168501610b64565b91508082528684828501011115610c09575f80fd5b80848401858401375f90820190930192909252509392505050565b5f60208284031215610c34575f80fd5b5035919050565b5f8060208385031215610c4c575f80fd5b823567ffffffffffffffff80821115610c63575f80fd5b818501915085601f830112610c76575f80fd5b813581811115610c84575f80fd5b8660208260051b8501011115610c98575f80fd5b60209290920196919550909350505050565b5f6020808385031215610cbb575f80fd5b823567ffffffffffffffff80821115610cd2575f80fd5b818501915085601f830112610ce5575f80fd5b813581811115610cf757610cf7610b50565b8060051b9150610d08848301610b64565b8181529183018401918481019088841115610d21575f80fd5b938501935b83851015610d3f57843582529385019390850190610d26565b98975050505050505050565b5f81518084525f5b81811015610d6f57602081850181015186830182015201610d53565b505f602082860101526020601f19601f83011685010191505092915050565b602081525f610b496020830184610d4b565b5f8060408385031215610db1575f80fd5b610dba83610b15565b946020939093013593505050565b634e487b7160e01b5f52601160045260245ffd5b8082018082111561074c5761074c610dc8565b600181811c90821680610e0357607f821691505b602082108103610e2157634e487b7160e01b5f52602260045260245ffd5b50919050565b601f821115610e70575f81815260208120601f850160051c81016020861015610e4d5750805b601f850160051c820191505b81811015610e6c57828155600101610e59565b5050505b505050565b815167ffffffffffffffff811115610e8f57610e8f610b50565b610ea381610e9d8454610def565b84610e27565b602080601f831160018114610ed6575f8415610ebf5750858301515b5f19600386901b1c1916600185901b178555610e6c565b5f85815260208120601f198616915b82811015610f0457888601518255948401946001909101908401610ee5565b5085821015610f2157878501515f19600388901b60f8161c191681555b5050505050600190811b01905550565b604081525f610f436040830185610d4b565b8281036020840152610f558185610d4b565b95945050505050565b634e487b7160e01b5f52603260045260245ffd5b5f60018201610f8357610f83610dc8565b5060010190565b8181038181111561074c5761074c610dc8565b634e487b7160e01b5f52603160045260245ffdfea26469706673582212203bdd908e340cfe2ced40d47d5fa4475b337c74052844dd856204288eaed5e46164736f6c63430008140033","sourceMap":"3129:85750:38:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;86777:477;;;;;;;;;;-1:-1:-1;86777:477:38;;;;;:::i;:::-;-1:-1:-1;;;;;87186:18:38;86836:4;87186:18;;;:8;:18;;;;;;:22;;;86777:477;;;;548:14:40;;541:22;523:41;;511:2;496:18;86777:477:38;;;;;;;;7331:20;;;;;;;;;;-1:-1:-1;7331:20:38;;;;-1:-1:-1;;;7331:20:38;;;;;;33474:1079;;;;;;;;;;;;;:::i;:::-;;8879:43;;;;;;;;;;-1:-1:-1;8879:43:38;;;;;:::i;:::-;;;;;;;;;;;;;;;;;721:25:40;;;709:2;694:18;8879:43:38;575:177:40;37238:976:38;;;;;;;;;;-1:-1:-1;37238:976:38;;;;;:::i;:::-;;:::i;27946:1325::-;;;;;;;;;;-1:-1:-1;27946:1325:38;;;;;:::i;:::-;;:::i;82478:591::-;;;;;;;;;;-1:-1:-1;82478:591:38;;;;;:::i;:::-;;:::i;88304:573::-;;;;;;;;;;-1:-1:-1;88464:227:38;;;;;;;;;88503:3;88464:227;;;88534:3;88464:227;;;;;;;88613:42;88464:227;;;;;;88569:15;88464:227;;;;;;;;;88676:4;88464:227;;;;;;;88304:573;;3047:34:40;;;3097:18;;;3090:43;;;;3149:18;;;3142:59;;;;3217:18;;;3210:60;;;;3286:19;;;3279:51;;;;2966:19;88304:573:38;2743:593:40;71758:696:38;;;;;;;;;;-1:-1:-1;71758:696:38;;;;;:::i;:::-;-1:-1:-1;;;;;72116:14:38;;;71837;72116;;;:5;:14;;;;;;;;;72097:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;71758:696;;;;;;;;;-1:-1:-1;;;;;3555:32:40;;;3537:51;;3619:2;3604:18;;3597:34;;;;3674:14;3667:22;3647:18;;;3640:50;3525:2;3510:18;71758:696:38;3341:355:40;7766:19:38;;;;;;;;;;;;;;;;6397:21;;;;;;;;;;;;;;;;56508:631;;;;;;;;;;-1:-1:-1;56508:631:38;;;;;:::i;:::-;;:::i;6899:20::-;;;;;;;;;;-1:-1:-1;6899:20:38;;;;-1:-1:-1;;;;;6899:20:38;;;;;;-1:-1:-1;;;;;4047:32:40;;;4029:51;;4017:2;4002:18;6899:20:38;3883:203:40;10087:37:38;;;;;;;;;;-1:-1:-1;10087:37:38;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;10087:37:38;;;;;;;;;24570:1059;;;:::i;9720:24::-;;;;;;;;;;-1:-1:-1;9720:24:38;;;;;:::i;:::-;;:::i;77167:951::-;;;;;;;;;;-1:-1:-1;77167:951:38;;;;;:::i;:::-;;:::i;8096:21::-;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;40235:261::-;;;;;;;;;;-1:-1:-1;40235:261:38;;;;;:::i;:::-;;:::i;61374:1309::-;;;;;;;;;;-1:-1:-1;61374:1309:38;;;;;:::i;:::-;;:::i;32072:380::-;;;;;;;;;;-1:-1:-1;32114:7:38;32373:6;32072:380;;51927:317;;;;;;;;;;-1:-1:-1;52185:7:38;:14;51927:317;;44011:364;;;;;;;;;;-1:-1:-1;44011:364:38;;;;;:::i;:::-;-1:-1:-1;;;;;44291:18:38;44070:7;44291:18;;;:8;:18;;;;;;;44011:364;66711:1049;;;;;;;;;;-1:-1:-1;66711:1049:38;;;;;:::i;:::-;;:::i;49213:722::-;;;;;;;;;;-1:-1:-1;49213:722:38;;;;;:::i;:::-;49661:7;:21;;;;;;;-1:-1:-1;49661:21:38;;;;;;;49213:722;33474:1079;34252:1;34242:6;;:11;;;;;;;:::i;:::-;;;;-1:-1:-1;;33474:1079:38:o;37238:976::-;37512:24;37539:7;37512:34;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;37902:8;37892:7;:18;;;;;;:::i;:::-;;38171:36;38186:10;38198:8;38171:36;;;;;;;:::i;:::-;;;;;;;;37289:925;37238:976;:::o;27946:1325::-;28538:16;28557:6;;28865:16;;;29201:32;;28557:6;;28874:7;;28557:6;;29201:32;;;27989:1282;27946:1325;:::o;82478:591::-;82549:7;82727:15;82719:42;;;;-1:-1:-1;;;82719:42:38;;9395:2:40;82719:42:38;;;9377:21:40;9434:2;9414:18;;;9407:30;-1:-1:-1;;;9453:18:40;;;9446:44;9507:18;;82719:42:38;;;;;;;;;83005:4;;83010:1;83005:7;;;;;;;:::i;:::-;;;;;;;82998:14;;82478:591;;;;;:::o;56508:631::-;56802:7;:14;56566:7;;56793:23;;56785:55;;;;-1:-1:-1;;;56785:55:38;;9870:2:40;56785:55:38;;;9852:21:40;9909:2;9889:18;;;9882:30;-1:-1:-1;;;9928:18:40;;;9921:49;9987:18;;56785:55:38;9668:343:40;56785:55:38;57064:7;57072:6;57064:15;;;;;;;;:::i;:::-;;;;;;;;;57057:22;;56508:631;;;:::o;24570:1059::-;24833:1;24821:9;:13;24813:63;;;;-1:-1:-1;;;24813:63:38;;10218:2:40;24813:63:38;;;10200:21:40;10257:2;10237:18;;;10230:30;10296:34;10276:18;;;10269:62;-1:-1:-1;;;10347:18:40;;;10340:35;10392:19;;24813:63:38;10016:401:40;24813:63:38;25302:10;25293:20;;;;:8;:20;;;;;:33;;25317:9;;25293:20;:33;;25317:9;;25293:33;:::i;:::-;;;;-1:-1:-1;;25585:37:38;;25612:9;721:25:40;;25600:10:38;;25585:37;;709:2:40;694:18;25585:37:38;;;;;;;24570:1059::o;9720:24::-;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;9720:24:38;:::o;77167:951::-;77235:7;;;77611:309;77635:4;:11;77631:1;:15;77611:309;;;77862:4;77867:1;77862:7;;;;;;;;:::i;:::-;;;;;;;77855:14;;;;;:::i;:::-;;-1:-1:-1;77648:3:38;;;;:::i;:::-;;;;77611:309;;;-1:-1:-1;78108:3:38;77167:951;-1:-1:-1;;77167:951:38:o;8096:21::-;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;40235:261::-;-1:-1:-1;;;;;40382:18:38;;;;;;:8;:18;;;;;;;;;:29;;;40455:34;;10736:51:40;;;10803:18;;10796:34;;;40455::38;;10709:18:40;40455:34:38;10562:274:40;61374:1309:38;61556:7;:14;61547:23;;61539:55;;;;-1:-1:-1;;;61539:55:38;;9870:2:40;61539:55:38;;;9852:21:40;9909:2;9889:18;;;9882:30;-1:-1:-1;;;9928:18:40;;;9921:49;9987:18;;61539:55:38;9668:343:40;61539:55:38;61781:7;:14;61761:17;;61781:18;;61798:1;;61781:18;:::i;:::-;61761:38;;62275:7;62283:9;62275:18;;;;;;;;:::i;:::-;;;;;;;;;62257:7;62265:6;62257:15;;;;;;;;:::i;:::-;;;;;;;;;;:36;62623:7;:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;61419:1264;61374:1309;:::o;66711:1049::-;67003:242;;;;;;;;-1:-1:-1;;;;;67003:242:38;;;;;;;;;;;;;67176:4;67003:242;;;;;;-1:-1:-1;66986:14:38;;;:5;:14;;;;;:259;;;;-1:-1:-1;;;;;;66986:259:38;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;66986:259:38;;;;;;;;;;;67720:33;;721:25:40;;;67003:242:38;;67720:33;;694:18:40;67720:33:38;;;;;;;66711:1049;;:::o;14:173:40:-;82:20;;-1:-1:-1;;;;;131:31:40;;121:42;;111:70;;177:1;174;167:12;111:70;14:173;;;:::o;192:186::-;251:6;304:2;292:9;283:7;279:23;275:32;272:52;;;320:1;317;310:12;272:52;343:29;362:9;343:29;:::i;:::-;333:39;192:186;-1:-1:-1;;;192:186:40:o;757:127::-;818:10;813:3;809:20;806:1;799:31;849:4;846:1;839:15;873:4;870:1;863:15;889:275;960:2;954:9;1025:2;1006:13;;-1:-1:-1;;1002:27:40;990:40;;1060:18;1045:34;;1081:22;;;1042:62;1039:88;;;1107:18;;:::i;:::-;1143:2;1136:22;889:275;;-1:-1:-1;889:275:40:o;1169:764::-;1238:6;1269:2;1312;1300:9;1291:7;1287:23;1283:32;1280:52;;;1328:1;1325;1318:12;1280:52;1368:9;1355:23;1397:18;1438:2;1430:6;1427:14;1424:34;;;1454:1;1451;1444:12;1424:34;1492:6;1481:9;1477:22;1467:32;;1537:7;1530:4;1526:2;1522:13;1518:27;1508:55;;1559:1;1556;1549:12;1508:55;1595:2;1582:16;1617:2;1613;1610:10;1607:36;;;1623:18;;:::i;:::-;1665:53;1708:2;1689:13;;-1:-1:-1;;1685:27:40;1681:36;;1665:53;:::i;:::-;1652:66;;1741:2;1734:5;1727:17;1781:7;1776:2;1771;1767;1763:11;1759:20;1756:33;1753:53;;;1802:1;1799;1792:12;1753:53;1857:2;1852;1848;1844:11;1839:2;1832:5;1828:14;1815:45;1901:1;1880:14;;;1876:23;;;1869:34;;;;-1:-1:-1;1884:5:40;1169:764;-1:-1:-1;;;1169:764:40:o;1938:180::-;1997:6;2050:2;2038:9;2029:7;2025:23;2021:32;2018:52;;;2066:1;2063;2056:12;2018:52;-1:-1:-1;2089:23:40;;1938:180;-1:-1:-1;1938:180:40:o;2123:615::-;2209:6;2217;2270:2;2258:9;2249:7;2245:23;2241:32;2238:52;;;2286:1;2283;2276:12;2238:52;2326:9;2313:23;2355:18;2396:2;2388:6;2385:14;2382:34;;;2412:1;2409;2402:12;2382:34;2450:6;2439:9;2435:22;2425:32;;2495:7;2488:4;2484:2;2480:13;2476:27;2466:55;;2517:1;2514;2507:12;2466:55;2557:2;2544:16;2583:2;2575:6;2572:14;2569:34;;;2599:1;2596;2589:12;2569:34;2652:7;2647:2;2637:6;2634:1;2630:14;2626:2;2622:23;2618:32;2615:45;2612:65;;;2673:1;2670;2663:12;2612:65;2704:2;2696:11;;;;;2726:6;;-1:-1:-1;2123:615:40;;-1:-1:-1;;;;2123:615:40:o;4091:946::-;4175:6;4206:2;4249;4237:9;4228:7;4224:23;4220:32;4217:52;;;4265:1;4262;4255:12;4217:52;4305:9;4292:23;4334:18;4375:2;4367:6;4364:14;4361:34;;;4391:1;4388;4381:12;4361:34;4429:6;4418:9;4414:22;4404:32;;4474:7;4467:4;4463:2;4459:13;4455:27;4445:55;;4496:1;4493;4486:12;4445:55;4532:2;4519:16;4554:2;4550;4547:10;4544:36;;;4560:18;;:::i;:::-;4606:2;4603:1;4599:10;4589:20;;4629:28;4653:2;4649;4645:11;4629:28;:::i;:::-;4691:15;;;4761:11;;;4757:20;;;4722:12;;;;4789:19;;;4786:39;;;4821:1;4818;4811:12;4786:39;4845:11;;;;4865:142;4881:6;4876:3;4873:15;4865:142;;;4947:17;;4935:30;;4898:12;;;;4985;;;;4865:142;;;5026:5;4091:946;-1:-1:-1;;;;;;;;4091:946:40:o;5042:423::-;5084:3;5122:5;5116:12;5149:6;5144:3;5137:19;5174:1;5184:162;5198:6;5195:1;5192:13;5184:162;;;5260:4;5316:13;;;5312:22;;5306:29;5288:11;;;5284:20;;5277:59;5213:12;5184:162;;;5188:3;5391:1;5384:4;5375:6;5370:3;5366:16;5362:27;5355:38;5454:4;5447:2;5443:7;5438:2;5430:6;5426:15;5422:29;5417:3;5413:39;5409:50;5402:57;;;5042:423;;;;:::o;5470:220::-;5619:2;5608:9;5601:21;5582:4;5639:45;5680:2;5669:9;5665:18;5657:6;5639:45;:::i;5695:254::-;5763:6;5771;5824:2;5812:9;5803:7;5799:23;5795:32;5792:52;;;5840:1;5837;5830:12;5792:52;5863:29;5882:9;5863:29;:::i;:::-;5853:39;5939:2;5924:18;;;;5911:32;;-1:-1:-1;;;5695:254:40:o;5954:127::-;6015:10;6010:3;6006:20;6003:1;5996:31;6046:4;6043:1;6036:15;6070:4;6067:1;6060:15;6086:125;6151:9;;;6172:10;;;6169:36;;;6185:18;;:::i;6216:380::-;6295:1;6291:12;;;;6338;;;6359:61;;6413:4;6405:6;6401:17;6391:27;;6359:61;6466:2;6458:6;6455:14;6435:18;6432:38;6429:161;;6512:10;6507:3;6503:20;6500:1;6493:31;6547:4;6544:1;6537:15;6575:4;6572:1;6565:15;6429:161;;6216:380;;;:::o;6727:545::-;6829:2;6824:3;6821:11;6818:448;;;6865:1;6890:5;6886:2;6879:17;6935:4;6931:2;6921:19;7005:2;6993:10;6989:19;6986:1;6982:27;6976:4;6972:38;7041:4;7029:10;7026:20;7023:47;;;-1:-1:-1;7064:4:40;7023:47;7119:2;7114:3;7110:12;7107:1;7103:20;7097:4;7093:31;7083:41;;7174:82;7192:2;7185:5;7182:13;7174:82;;;7237:17;;;7218:1;7207:13;7174:82;;;7178:3;;;6818:448;6727:545;;;:::o;7448:1352::-;7574:3;7568:10;7601:18;7593:6;7590:30;7587:56;;;7623:18;;:::i;:::-;7652:97;7742:6;7702:38;7734:4;7728:11;7702:38;:::i;:::-;7696:4;7652:97;:::i;:::-;7804:4;;7868:2;7857:14;;7885:1;7880:663;;;;8587:1;8604:6;8601:89;;;-1:-1:-1;8656:19:40;;;8650:26;8601:89;-1:-1:-1;;7405:1:40;7401:11;;;7397:24;7393:29;7383:40;7429:1;7425:11;;;7380:57;8703:81;;7850:944;;7880:663;6674:1;6667:14;;;6711:4;6698:18;;-1:-1:-1;;7916:20:40;;;8034:236;8048:7;8045:1;8042:14;8034:236;;;8137:19;;;8131:26;8116:42;;8229:27;;;;8197:1;8185:14;;;;8064:19;;8034:236;;;8038:3;8298:6;8289:7;8286:19;8283:201;;;8359:19;;;8353:26;-1:-1:-1;;8442:1:40;8438:14;;;8454:3;8434:24;8430:37;8426:42;8411:58;8396:74;;8283:201;-1:-1:-1;;;;;8530:1:40;8514:14;;;8510:22;8497:36;;-1:-1:-1;7448:1352:40:o;8805:383::-;9002:2;8991:9;8984:21;8965:4;9028:45;9069:2;9058:9;9054:18;9046:6;9028:45;:::i;:::-;9121:9;9113:6;9109:22;9104:2;9093:9;9089:18;9082:50;9149:33;9175:6;9167;9149:33;:::i;:::-;9141:41;8805:383;-1:-1:-1;;;;;8805:383:40:o;9536:127::-;9597:10;9592:3;9588:20;9585:1;9578:31;9628:4;9625:1;9618:15;9652:4;9649:1;9642:15;10422:135;10461:3;10482:17;;;10479:43;;10502:18;;:::i;:::-;-1:-1:-1;10549:1:40;10538:13;;10422:135::o;10841:128::-;10908:9;;;10929:11;;;10926:37;;;10943:18;;:::i;10974:127::-;11035:10;11030:3;11026:20;11023:1;11016:31;11066:4;11063:1;11056:15;11090:4;11087:1;11080:15","linkReferences":{}},"methodIdentifiers":{"addNumber(uint256)":"fce68023","balances(address)":"27e235e3","data()":"73d4a13a","deposit()":"d0e30db0","getBalance(address)":"f8b2cb4f","getFirstElement(uint256[])":"46b71fff","getNumber()":"f2c9ecd8","getNumberAt(uint256)":"8af79949","getNumbersLength()":"f3d4e562","getPackedDataExample()":"4be58131","getUser(address)":"6f77926b","hasBalance(address)":"22b2678a","incrementNumber()":"273ea3e3","isActive()":"22f3e2d4","message()":"e21f37ce","number()":"8381f58a","numbers(uint256)":"d39fa233","owner()":"8da5cb5b","registerUser(address,uint256)":"fa0b5e55","removeNumber(uint256)":"eea54fb6","setBalance(address,uint256)":"e30443bc","setMessage(string)":"368b8772","setNumber(uint256)":"3fb5c1cb","sumMemoryArray(uint256[])":"e16633a4","users(address)":"a87430ba"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldMessage\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newMessage\",\"type\":\"string\"}],\"name\":\"MessageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"NumberUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"addNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_arr\",\"type\":\"uint256[]\"}],\"name\":\"getFirstElement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getNumberAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumbersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPackedDataExample\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"hasBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"message\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"setMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"setNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_arr\",\"type\":\"uint256[]\"}],\"name\":\"sumMemoryArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract showcases:      - Value types (uint, address, bool, bytes32)      - Reference types (arrays, structs, mappings)      - Data locations (storage, memory, calldata)      - Gas-efficient struct packing      - Common patterns and best practices ????????????????????????????????????????????????????????????????????????????                        CONCEPTUAL OVERVIEW ???????????????????????????????????????????????????????????????????????????? SOLIDITY TYPE SYSTEM: Why so strict? ????????????????????????????????????  REAL-WORLD ANALOGY: Solidity types are like numbered lockers in a gym. Each locker (variable) has a fixed size (type) and can only hold items that fit exactly. Unlike TypeScript/Go/Rust where storage is flexible, Solidity requires exact sizes because every node on the blockchain must compute the same storage layout. Unlike TypeScript/Go/Rust (static typing with inference), Solidity requires explicit types and sizes because the EVM (Ethereum Virtual Machine) needs to:   1. Calculate exact gas costs at compile time   2. Determine storage layout deterministically   3. Prevent type confusion attacks   4. Enable all nodes to compute identical state COMPARISON TO OTHER LANGUAGES: ????????????????????????????????  TypeScript:   let x: number = 42;  // Static typing with inference   x = \\\"hello\\\";  // Compile error ? Go:   var x uint256 = 42  // Static, explicit types   x = \\\"hello\\\"  // Compile error ? Rust:   let x: u256 = 42;  // Static, strong inference   x = \\\"hello\\\";  // Compile error ? Solidity:   uint256 x = 42;  // Static, explicit, NO inference, fixed size   x = \\\"hello\\\";  // Compile error ?   // Must always specify type AND size STORAGE MODEL: ??????????????  REAL-WORLD ANALOGY: Storage slots are like numbered lockers in a gym. Each locker (slot) can hold exactly 32 bytes (256 bits). You can pack multiple small items (variables) into one locker if they fit, saving money (gas). Reading/writing to lockers costs money - first access is expensive (cold), subsequent accesses are cheaper (warm). Every contract has 2^256 storage slots (each 32 bytes / 256 bits) State variables are packed into slots sequentially Variables < 32 bytes can share slots if declared consecutively COSTS (as of 2024): ???????????????????? - SSTORE (cold): ~20,000 gas (first write to slot) - like renting a new locker - SSTORE (warm): ~5,000 gas (update existing slot) - like accessing your locker - SLOAD (cold): ~2,100 gas (first read from slot) - like opening a locker for first time - SLOAD (warm): ~100 gas (subsequent reads) - like quickly checking your locker - Memory: ~3 gas per 32-byte word - like using a temporary desk - Calldata: cheapest, read-only from transaction data - like reading a letter\",\"events\":{\"BalanceUpdated(address,uint256)\":{\"details\":\"Both parameters are non-indexed\"},\"FundsDeposited(address,uint256)\":{\"details\":\"depositor is indexed for efficient filtering      Frontends can listen to all deposits from a specific address\"},\"MessageUpdated(string,string)\":{\"details\":\"Strings can't be indexed (too large)      Both parameters are non-indexed (stored as data)\"},\"NumberUpdated(uint256,uint256)\":{\"details\":\"EVENTS: The Bridge Between On-Chain and Off-Chain \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Events are like receipts - they prove something happened on-chain!      But unlike storage, they're optimized for off-chain consumption.      HOW EVENTS WORK:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Contract emits event                    \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Event data stored in transaction log    \\u2502 \\u2190 Cheaper than storage!      \\u2502   \\u2193                                      \\u2502      \\u2502 Off-chain systems listen to events       \\u2502 \\u2190 Indexers, frontends      \\u2502   \\u2193                                      \\u2502      \\u2502 UI updates in real-time                 \\u2502 \\u2190 Magic! \\u2728      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Events are stored in transaction logs, not contract storage!      This makes them:      - Cheaper (~2,000 gas vs ~20,000 gas for storage)      - Searchable (can filter by indexed parameters)      - Perfect for off-chain systems      INDEXED PARAMETERS: The Search Feature      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Indexed parameters are like searchable tags:      - Can filter events by indexed values      - Up to 3 indexed parameters per event      - Each indexed param costs ~375 gas extra      Example: Filter all NumberUpdated events where oldValue = 100      ```javascript      contract.on(\\\"NumberUpdated\\\", { oldValue: 100 }, (event) => {          console.log(\\\"Number was updated from 100!\\\");      });      ```      CONNECTION TO STORAGE:      Events complement storage:      - Storage: For on-chain state (expensive, persistent)      - Events: For off-chain indexing (cheap, searchable)      - Best practice: Use both! Store state, emit events for tracking.      REAL-WORLD ANALOGY:      Like a receipt system:      - Storage = The actual inventory (what's in stock)      - Events = Receipts (proof of transactions)      - Frontend = Cash register display (shows events in real-time)      GAS COST:      - Base event: ~375 gas      - Each indexed param: +375 gas      - Each non-indexed param: +375 gas (for data)      TOTAL: ~2,000-3,000 gas (much cheaper than storage!)      \\ud83c\\udf93 LEARNING MOMENT:      Events are your contract's \\\"API\\\" for off-chain systems!      Frontends, indexers, and analytics tools all rely on events.      Without events, off-chain systems would have to constantly poll storage      (expensive and inefficient!). Events make blockchain data accessible!\"},\"UserRegistered(address,uint256)\":{\"details\":\"Notice: wallet is indexed (searchable), balance is not      This allows filtering by wallet address efficiently\"}},\"kind\":\"dev\",\"methods\":{\"addNumber(uint256)\":{\"details\":\"ARRAYS: Ordered Collections with Hidden Complexity \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Arrays in Solidity are like numbered shelves in a warehouse.      Each item has a position (index), and you can add items to the end.      HOW ARRAYS ARE STORED:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Slot 6: Length (how many items)            \\u2502 \\u2190 Stored separately!      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 Slot keccak256(6) + 0: numbers[0]          \\u2502 \\u2190 First element      \\u2502 Slot keccak256(6) + 1: numbers[1]          \\u2502 \\u2190 Second element      \\u2502 Slot keccak256(6) + 2: numbers[2]          \\u2502 \\u2190 Third element      \\u2502 ...                                         \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: The length and elements are stored SEPARATELY!      This is different from languages like Python where length is calculated.      In Solidity, length is a state variable that must be updated manually.      WHAT HAPPENS WHEN YOU PUSH:      Step 1: Read current length (SLOAD: ~100 gas warm)      Step 2: Write new length = old_length + 1 (SSTORE: ~5,000 gas warm)      Step 3: Calculate new element slot = keccak256(6) + new_length      Step 4: Write element to that slot (SSTORE: ~5,000 gas warm)            TOTAL: ~10,000+ gas (warm) or ~40,000+ gas (cold)      CONNECTION TO MAPPINGS:      Notice the storage calculation? It's similar to mappings!      - Mapping: slot = keccak256(key, mapping_slot)      - Array: slot = keccak256(array_slot) + index      Both use keccak256, but arrays use sequential indices!      For our numbers array: slot = keccak256(6) + index      REAL-WORLD ANALOGY:      Think of a library:      - Length = catalog showing how many books      - Elements = actual books on numbered shelves      - push() = add a new book and update the catalog      \\u26a0\\ufe0f  THE DANGER: Unbounded Growth!      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550            Arrays can grow FOREVER (up to 2^256 elements theoretically).      This creates a Denial of Service (DoS) vulnerability:      Example Attack:      ```solidity      // Attacker calls this repeatedly      function attack() public {          for(uint i = 0; i < 1000; i++) {              addNumber(i); // Makes array huge!          }      }            // Later, this becomes impossible (exceeds gas limit)      function processAll() public {          for(uint i = 0; i < numbers.length; i++) {              // Process numbers[i]...              // \\u274c FAILS if array too large!          }      }      ```      DEFENSE PATTERNS:      1. Limit array size: require(numbers.length < MAX_SIZE)      2. Use mappings instead (O(1) access, no iteration needed)      3. Emit events, process off-chain (indexers handle the heavy lifting)      GAS OPTIMIZATION TIP:      If you know the max size upfront, use fixed-size arrays!      ```solidity      uint256[10] public fixedNumbers; // Max 10 elements, cheaper!      ```      \\ud83c\\udf93 LEARNING MOMENT:      Why is push() expensive? Because it does TWO storage writes:      1. Update the length counter      2. Write the new element      Each storage write costs ~5,000 gas (warm) or ~20,000 gas (cold)!\",\"params\":{\"_number\":\"The number to add\"}},\"constructor\":{\"details\":\"Constructor runs ONCE on deployment \\ud83c\\udfd7\\ufe0f  CONSTRUCTORS: The One-Time Setup \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Constructors are special functions that run EXACTLY ONCE - when the contract is deployed.      Think of them as the \\\"birth\\\" of your contract - they set up the initial state.      HOW CONSTRUCTORS WORK:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Developer deploys contract             \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Constructor executes                   \\u2502 \\u2190 Runs ONCE, never again!      \\u2502   \\u2193                                      \\u2502      \\u2502 Initial state is set                    \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Contract is live on blockchain          \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Constructor code is DISCARDED           \\u2502 \\u2190 Not stored!      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Constructor code is NOT stored on-chain!      Only the runtime code (your functions) is stored.      The constructor runs during deployment, then disappears!      This saves gas - you don't pay to store initialization code forever.      WHY SET OWNER IN CONSTRUCTOR?      This is a CRITICAL security pattern:      1. Establishes who controls the contract      2. msg.sender during deployment = the deployer      3. Prevents anyone else from claiming ownership      4. Common pattern in \\\"Ownable\\\" contracts (like OpenZeppelin)      CONNECTION TO SECURITY:      Setting owner in constructor ensures:      - Only deployer can be owner (can't be changed later)      - No race conditions (set atomically during deployment)      - Clear ownership from the start      REAL-WORLD ANALOGY:      Like setting up a new bank account:      - Constructor = Opening the account (one-time setup)      - Owner = Account holder (who controls it)      - isActive = Account status (active/inactive)      GAS COST:      - Constructor execution: Included in deployment cost      - Setting owner: ~20,000 gas (cold write)      - Setting isActive: ~20,000 gas (cold write)      - Total deployment: ~200,000+ gas (includes bytecode storage)      \\u26a0\\ufe0f  IMPORTANT: Constructor can't be called again!      Once deployed, there's NO WAY to re-run the constructor.      This is why initialization must be complete and correct!      \\ud83c\\udf93 LEARNING MOMENT:      Constructors are your only chance to set initial state!      Make sure everything is initialized correctly here.      If you forget something, you'll need a separate initialization function      (but that's less secure - anyone could call it!).\"},\"deposit()\":{\"details\":\"Payable function - receives ETH and updates balance \\ud83d\\udcb0 RECEIVING ETH: The Magic of Payable Functions \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      This function is SPECIAL - it can receive Ether! Notice the `payable` keyword?      Without `payable`, sending ETH to this function would REVERT.      HOW IT WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 User sends transaction with ETH         \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Contract receives ETH automatically     \\u2502 \\u2190 Magic happens here!      \\u2502   \\u2193                                      \\u2502      \\u2502 msg.value contains the ETH amount       \\u2502 \\u2190 Accessible in function      \\u2502   \\u2193                                      \\u2502      \\u2502 Contract balance increases              \\u2502 \\u2190 No explicit transfer needed!      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Before Solidity 0.6.0, you had to use `address(this).balance`      to check received ETH. Now `msg.value` makes it explicit and safer!      CONNECTION TO MAPPINGS:      We're using the `balances` mapping we learned about earlier!      This is a real-world use case: tracking user deposits.      REAL-WORLD ANALOGY:      Think of this like a vending machine:      - You insert coins (send ETH)      - Machine records your credit (updates balances mapping)      - You can check your balance anytime (getBalance())      - Machine logs the transaction (emits event)      SECURITY CONSIDERATIONS:      \\u26a0\\ufe0f  Always validate msg.value > 0 (prevents accidental zero deposits)      \\u26a0\\ufe0f  Use += instead of = to handle multiple deposits correctly      \\u26a0\\ufe0f  Consider reentrancy protection for production contracts      GAS BREAKDOWN:      - require() check: ~3 gas (if passes)      - Mapping read + write: ~20,000 gas (cold) or ~5,000 gas (warm)      - Event emission: ~2,000 gas      TOTAL: ~22,000 gas (first deposit) or ~7,000 gas (subsequent)      PATTERN RECOGNITION:      Notice we use `+=` here? This is read-modify-write pattern.      We MUST read first (to get existing balance), then add, then write.      This is different from setBalance() where we just overwrite!      \\ud83c\\udf93 LEARNING MOMENT:      Why `+=` instead of `=`? Because users might deposit multiple times!      If Alice deposits 1 ETH, then 2 ETH, her balance should be 3 ETH total.      Using `=` would overwrite and lose the first deposit! \\ud83d\\ude31\"},\"getBalance(address)\":{\"details\":\"MAPPING DEFAULT VALUES: The Zero Mystery \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Here's something fascinating about Solidity mappings:      They ALWAYS return a value, even for keys that were never set!      THE ZERO DEFAULT:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Key never set? \\u2192 Returns 0         \\u2502 \\u2190 Not an error!      \\u2502 Key set to 0?   \\u2192 Returns 0         \\u2502 \\u2190 Same result!      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: This is different from most languages!      - Python: Raises KeyError if key doesn't exist      - JavaScript: Returns undefined      - Solidity: Returns the type's default value (0 for uint256)      WHY THIS DESIGN?      Solidity prioritizes gas efficiency and safety:      1. No need to check \\\"does key exist?\\\" (saves gas)      2. No risk of undefined/null errors (safer)      3. Predictable behavior (easier to reason about)      THE PROBLEM: Can't Distinguish States      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550            How do you know if someone has zero balance because:      A) They never deposited (key doesn't exist)      B) They deposited and withdrew everything (key exists, value is 0)      SOLUTION PATTERNS:            Pattern 1: Separate existence mapping      ```solidity      mapping(address => bool) public hasDeposited;      mapping(address => uint256) public balances;            function deposit() public payable {          hasDeposited[msg.sender] = true;  // Mark as existing          balances[msg.sender] += msg.value;      }      ```      Pattern 2: Use non-zero sentinel value      ```solidity      // Reserve 0 for \\\"never set\\\", use 1 wei minimum for \\\"exists\\\"      ```      CONNECTION TO STORAGE:      Remember how mappings calculate storage slots?      slot = keccak256(key, mapping_slot)      If that slot was never written to, it contains all zeros!      That's why we get 0 back - it's literally reading empty storage!      REAL-WORLD ANALOGY:      Like checking a mailbox:      - Empty mailbox (never used) = 0 letters      - Mailbox with 0 letters (all removed) = 0 letters      You can't tell which is which just by looking!      GAS COST:      - Cold read: ~2,100 gas (first time accessing this address)      - Warm read: ~100 gas (subsequent reads)      - No gas if called off-chain (view functions are free when called externally)      \\ud83c\\udf93 LEARNING MOMENT:      This is why `hasBalance()` exists! It's a helper that checks if balance > 0.      But remember: balance = 0 doesn't mean \\\"never set\\\" - it could mean \\\"withdrawn everything\\\"!\",\"params\":{\"_address\":\"The address to query\"},\"returns\":{\"_0\":\"The balance amount\"}},\"getFirstElement(uint256[])\":{\"details\":\"CALLDATA: The Zero-Copy Champion! \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Calldata is the MOST gas-efficient data location!      It's read-only data that comes directly from the transaction.      HOW CALLDATA WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 User sends transaction with data        \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Data stored in transaction calldata    \\u2502 \\u2190 Already on-chain!      \\u2502   \\u2193                                      \\u2502      \\u2502 Function reads directly from calldata   \\u2502 \\u2190 No copy needed!      \\u2502   \\u2193                                      \\u2502      \\u2502 Function returns                         \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Calldata is part of the transaction itself!      When you call a function, the parameters are encoded in the transaction.      Calldata lets you read directly from that transaction data - zero copy!      THE THREE DATA LOCATIONS COMPARED:            Storage (Most Expensive):      - Cost: ~20,000 gas/write, ~100 gas/read (warm)      - Use: Persistent state      - Example: State variables      Memory (Medium Cost):      - Cost: ~3 gas/word allocation      - Use: Temporary calculations      - Example: Local variables, return values      Calldata (Cheapest!):      - Cost: ~100 gas (just reading, no allocation)      - Use: Function parameters (external functions)      - Example: Arrays/strings passed to external functions      CONNECTION TO GAS OPTIMIZATION:      Remember: gas = money on Ethereum!      Using calldata instead of memory can save thousands of gas.      For a 100-element array:      - Memory: ~300 gas (copy 100 words \\u00d7 3 gas)      - Calldata: ~100 gas (just read, no copy)      Savings: 200 gas per call!      REAL-WORLD ANALOGY:      - Storage = Filing cabinet (expensive to access)      - Memory = Photocopying a document (costs money)      - Calldata = Reading the original document (free!)      \\u26a0\\ufe0f  RESTRICTIONS:      - Only available in EXTERNAL functions      - Cannot be modified (read-only)      - Cannot be used in internal/public functions      WHY EXTERNAL?      External functions are more gas-efficient than public:      - Public: Can be called internally (requires memory copy)      - External: Only callable externally (can use calldata)      - Trade-off: Can't call from within contract (use this.functionName())      GAS COMPARISON (100-element array):      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Location    \\u2502 Allocation  \\u2502 Read First El   \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 calldata    \\u2502 0 gas       \\u2502 ~100 gas        \\u2502 \\u2190 Winner!      \\u2502 memory      \\u2502 ~300 gas    \\u2502 ~103 gas        \\u2502      \\u2502 storage     \\u2502 N/A         \\u2502 ~100 gas        \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      \\ud83c\\udf93 LEARNING MOMENT:      Always use calldata for arrays/strings in external functions!      It's the most gas-efficient option and makes your intent clear.      Only use memory if you need to modify the data.\",\"params\":{\"_arr\":\"Array to process (in calldata)\"},\"returns\":{\"_0\":\"The first element\"}},\"getNumber()\":{\"details\":\"VIEW FUNCTIONS: Reading State Without Cost \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      View functions are special - they can read state but not modify it.      When called off-chain, they're FREE! No gas cost at all!      HOW VIEW FUNCTIONS WORK:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Off-chain call (e.g., from frontend)     \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Function executes locally                \\u2502 \\u2190 No transaction!      \\u2502   \\u2193                                      \\u2502      \\u2502 Reads state (simulated)                  \\u2502 \\u2190 Free!      \\u2502   \\u2193                                      \\u2502      \\u2502 Returns value                            \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: View functions don't create transactions!      They're executed locally by your node, then the result is returned.      This is why they're free - nothing is written to the blockchain!      WHEN DO VIEW FUNCTIONS COST GAS?      Only when called by another contract (on-chain call):      - Contract A calls Contract B's view function      - This happens in a transaction      - Gas is charged (~100 gas for SLOAD)      CONNECTION TO AUTOMATIC GETTERS:      Remember: `public uint256 number;` automatically creates a getter!      Solidity generates `function number() public view returns (uint256)`      So why write this explicit function?      - Demonstrates the concept      - Can add custom logic later      - Shows how view functions work      REAL-WORLD ANALOGY:      Like checking your bank balance:      - Off-chain: Look at your phone app (free, instant)      - On-chain: Bank teller checks computer (costs time/money)      GAS COST:      - Off-chain call: FREE! (no transaction)      - On-chain call: ~100 gas (SLOAD from storage)      \\ud83c\\udf93 LEARNING MOMENT:      View functions are perfect for frontends!      You can call them as many times as you want without paying gas.      This is why DApps can show real-time data - they're constantly      calling view functions to update the UI!\",\"returns\":{\"_0\":\"The current number value\"}},\"getNumberAt(uint256)\":{\"details\":\"ARRAY ACCESS: Bounds Checking is Your Friend \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Accessing array elements requires bounds checking.      Solidity does this automatically, but explicit checks are clearer!      HOW IT WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 1. Check: Is _index < numbers.length?   \\u2502 \\u2190 Our explicit check      \\u2502    \\u274c No \\u2192 REVERT with error message      \\u2502      \\u2502    \\u2705 Yes \\u2192 Continue                      \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 2. Calculate slot:                       \\u2502      \\u2502    slot = keccak256(6) + _index          \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 3. Read from storage (SLOAD)             \\u2502      \\u2502    Return the value                       \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Solidity 0.8.0+ has automatic bounds checking!      Even without our require(), accessing numbers[_index] where _index >= length      would revert automatically. But explicit checks are better because:      1. Clearer error messages (\\\"Index out of bounds\\\" vs generic panic)      2. More gas-efficient (our check happens before slot calculation)      3. Better developer experience      THE STORAGE CALCULATION:      Remember: array elements are stored at keccak256(base_slot) + index      For our numbers array (slot 6):      - numbers[0] \\u2192 slot = keccak256(6) + 0      - numbers[1] \\u2192 slot = keccak256(6) + 1      - numbers[2] \\u2192 slot = keccak256(6) + 2      CONNECTION TO MAPPINGS:      Arrays and mappings both use keccak256 for storage calculation!      - Mapping: keccak256(key, mapping_slot)      - Array: keccak256(array_slot) + index      The difference: arrays use sequential indices, mappings use arbitrary keys      LANGUAGE COMPARISON:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Language    \\u2502 Behavior on out-of-bounds    \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 C           \\u2502 Undefined behavior (danger!) \\u2502      \\u2502 Python      \\u2502 Raises IndexError             \\u2502      \\u2502 JavaScript  \\u2502 Returns undefined            \\u2502      \\u2502 Solidity    \\u2502 Reverts transaction (safe!)  \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      REAL-WORLD ANALOGY:      Like asking for book #1000 in a library with only 100 books:      - C: Gives you garbage data (undefined behavior)      - Python: Throws an error (IndexError)      - Solidity: Stops everything, refunds gas (revert)      GAS COST:      - require() check: ~3 gas (if passes)      - Storage read: ~2,100 gas (cold) or ~100 gas (warm)      TOTAL: ~2,103 gas (cold) or ~103 gas (warm)      \\ud83c\\udf93 LEARNING MOMENT:      Why check bounds explicitly? Because it's cheaper!      If we don't check and Solidity's automatic check triggers,      we've already wasted gas calculating the storage slot.      Our explicit check prevents that waste!\",\"params\":{\"_index\":\"The index to query\"},\"returns\":{\"_0\":\"The number at that index\"}},\"getNumbersLength()\":{\"details\":\"ARRAY LENGTH: A Stored Counter \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Unlike many languages, Solidity arrays store their length explicitly!      This is a design choice that prioritizes gas efficiency.      HOW IT WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Slot 6: numbers.length = 3       \\u2502 \\u2190 Stored as uint256      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: In Python, len(array) calculates length by counting elements.      In Solidity, .length just reads a stored value - much faster!      WHY STORE IT?      1. O(1) access time (constant, not linear)      2. No need to iterate to count elements      3. Prevents out-of-bounds errors (can check before access)      CONNECTION TO STORAGE MODEL:      Remember: length is stored in slot 6 (the array's base slot)      Elements are stored starting at keccak256(6) + index      This separation allows O(1) length access!      REAL-WORLD ANALOGY:      Like a library catalog:      - Python: Count books by walking through shelves (O(n))      - Solidity: Check the catalog card (O(1))      GAS COST:      - Cold read: ~2,100 gas (first access)      - Warm read: ~100 gas (subsequent reads)      - Free if called off-chain (view functions)      \\ud83c\\udf93 LEARNING MOMENT:      This is why checking `if (index < numbers.length)` is safe!      The length is always up-to-date because push() and pop() update it automatically.\",\"returns\":{\"_0\":\"The array length\"}},\"getPackedDataExample()\":{\"details\":\"This is just a view function to show that PackedData struct exists      In real usage, you'd store PackedData in a mapping or array EXAMPLE USAGE:   mapping(uint256 => PackedData) public packedDataStore;   function storePackedData(uint256 id) public {       packedDataStore[id] = PackedData({           smallNumber1: 100,           smallNumber2: 200,           timestamp: uint64(block.timestamp),           user: msg.sender,           flag: true       });   } GAS SAVINGS:   Without packing: 4 slots \\u00ef\\u00bf\\u00bd 20,000 gas = 80,000 gas   With packing: 2 slots \\u00ef\\u00bf\\u00bd 20,000 gas = 40,000 gas   SAVINGS: 50% reduction!\"},\"getUser(address)\":{\"details\":\"MULTIPLE RETURN VALUES: Solidity's Superpower! \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Solidity functions can return MULTIPLE values - like Python tuples!      This is incredibly useful and makes code cleaner.      HOW IT WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Function returns 3 values:              \\u2502      \\u2502   (address, uint256, bool)              \\u2502      \\u2502 \\u2193                                        \\u2502      \\u2502 Caller receives all 3 values            \\u2502      \\u2502   (wallet, balance, status) = getUser()\\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Named returns are a Solidity feature!      You can name the return values in the function signature,      and then just assign to them instead of using return!      EXAMPLE WITH NAMED RETURNS:      ```solidity      function getUser(address _wallet)          public view          returns (address wallet, uint256 balance, bool isRegistered)      {          wallet = users[_wallet].wallet;  // Just assign!          balance = users[_wallet].balance;          isRegistered = users[_wallet].isRegistered;          // No return statement needed!      }      ```      DATA LOCATION: Storage vs Memory      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      When reading structs from mappings, you have two choices:      Option 1: Storage Reference (Cheaper, but Read-Only)      ```solidity      User storage user = users[_wallet];      // user is a REFERENCE to storage      // Can't modify (would need special syntax)      ```      Option 2: Memory Copy (What we use!)      ```solidity      User memory user = users[_wallet];      // user is a COPY in memory      // Safe to read, can modify copy (doesn't affect storage)      ```      WHY MEMORY HERE?      1. We're returning values - memory is perfect for this      2. Clear intent: we're reading, not modifying      3. Slightly more gas (copying), but safer and clearer      CONNECTION TO EARLIER CONCEPTS:      Remember storage vs memory vs calldata?      - Storage: Persistent, expensive (~20k gas/write)      - Memory: Temporary, cheap (~3 gas/word)      - Calldata: Read-only, cheapest (no copy)      REAL-WORLD ANALOGY:      Like photocopying a document:      - Storage reference = Pointing to original (cheap, but can't modify)      - Memory copy = Photocopy (costs a bit, but safe to modify)      GAS COST:      - Read wallet: ~2,100 gas (cold) or ~100 gas (warm)      - Read balance: ~2,100 gas (cold) or ~100 gas (warm)      - Read isRegistered: ~2,100 gas (cold) or ~100 gas (warm)      - Copy to memory: ~9 gas (3 words \\u00d7 3 gas)      TOTAL: ~6,309 gas (cold) or ~309 gas (warm)      \\ud83c\\udf93 LEARNING MOMENT:      Why copy to memory? Because we're returning the values!      Return values must be in memory (or calldata for external functions).      This is a Solidity requirement - you can't return storage references!\",\"params\":{\"_wallet\":\"The user's wallet address\"},\"returns\":{\"balance\":\"amount\",\"isRegistered\":\"status\",\"wallet\":\"address\"}},\"hasBalance(address)\":{\"details\":\"HELPER FUNCTIONS: Making Code More Readable \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Helper functions are like shortcuts - they make code cleaner and easier to understand.      Instead of writing `balances[_address] > 0` everywhere, we create a helper!      THE MAPPING ZERO PROBLEM:      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Remember the \\\"zero default\\\" behavior we learned about?      Mappings always return 0 for non-existent keys.      This creates an ambiguity:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 balances[alice] = 0                        \\u2502      \\u2502                                             \\u2502      \\u2502 Does this mean:                            \\u2502      \\u2502   A) Alice never deposited?                 \\u2502      \\u2502   B) Alice deposited and withdrew all?      \\u2502      \\u2502                                             \\u2502      \\u2502 We can't tell! Both return 0!              \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      WHAT THIS FUNCTION DOES:      This function checks if balance > 0.      It's a simple check, but it's useful because:      1. More readable than `balances[_address] > 0`      2. Can be extended later (add more checks)      3. Documents intent clearly      CONNECTION TO EARLIER CONCEPTS:      This uses the mapping we learned about earlier!      We're reading from `balances` mapping and checking the value.      Simple, but demonstrates how concepts connect!      REAL-WORLD ANALOGY:      Like checking if a bank account has money:      - Balance = 0 \\u2192 No money (but was it ever used?)      - Balance > 0 \\u2192 Definitely has money!      BETTER PATTERN FOR EXISTENCE:      If you need to distinguish \\\"never set\\\" from \\\"set to 0\\\":      ```solidity      mapping(address => bool) public hasDeposited;      mapping(address => uint256) public balances;            function deposit() public payable {          hasDeposited[msg.sender] = true;  // Mark as existing          balances[msg.sender] += msg.value;      }            function hasBalance(address addr) public view returns (bool) {          return hasDeposited[addr] && balances[addr] > 0;      }      ```      GAS COST:      - Mapping read: ~2,100 gas (cold) or ~100 gas (warm)      - Comparison (> 0): ~3 gas      TOTAL: ~2,103 gas (cold) or ~103 gas (warm)      \\ud83c\\udf93 LEARNING MOMENT:      Helper functions make code more maintainable!      If you need to change the logic later (e.g., add minimum balance check),      you only change it in one place. This is the DRY principle:      Don't Repeat Yourself!\",\"params\":{\"_address\":\"The address to check\"},\"returns\":{\"_0\":\"true if balance > 0\"}},\"incrementNumber()\":{\"details\":\"SOLIDITY 0.8.0+ SAFETY:      If number == type(uint256).max, this reverts automatically      Pre-0.8.0: Would silently wrap to 0 (overflow) GAS OPTIMIZATION: Why use += instead of separate operations? - number += 1: 1 SLOAD + 1 SSTORE = ~5,100 gas (warm) - Alternative: uint256 temp = number; temp += 1; number = temp;   Costs: 1 SLOAD + 1 MLOAD + 1 ADD + 1 SSTORE = ~5,103 gas - Savings: Minimal (~3 gas), but += is cleaner GAS: ~5,000 gas if slot is warm (already accessed) ALTERNATIVE PATTERNS:   unchecked { number += 1; }  // Disable overflow check, save ~100 gas   But DANGEROUS if overflow is possible!   Only use unchecked when you're CERTAIN overflow can't happen REAL-WORLD ANALOGY: Like incrementing a counter - you read the current value, add 1, and write it back. Using += does this in one operation.\"},\"registerUser(address,uint256)\":{\"details\":\"STRUCTS: Custom Types That Group Related Data \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Structs are like custom containers that group related data together.      Think of them as \\\"mini-objects\\\" or \\\"records\\\" in other languages.      HOW STRUCTS ARE STORED IN MAPPINGS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Mapping slot calculation:                   \\u2502      \\u2502 base_slot = keccak256(_wallet, mapping_slot)\\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 base_slot + 0: wallet (address)            \\u2502 \\u2190 20 bytes, uses full slot      \\u2502 base_slot + 1: balance (uint256)           \\u2502 \\u2190 32 bytes      \\u2502 base_slot + 2: isRegistered (bool)         \\u2502 \\u2190 1 byte, uses full slot      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      Total: 3 storage slots per User struct      FUN FACT: Structs in mappings are stored sequentially!      Unlike arrays where elements are at keccak256(slot) + index,      struct fields are at base_slot + field_offset.      This makes struct access predictable and efficient!      THREE WAYS TO CREATE STRUCTS:            Method 1: Named Fields (Most Readable) \\u2705      ```solidity      User({wallet: _wallet, balance: _balance, isRegistered: true})      ```      Pros: Self-documenting, order doesn't matter      Cons: More verbose      Method 2: Positional (Concise)      ```solidity      User(_wallet, _balance, true)      ```      Pros: Shorter      Cons: Must remember field order, less readable      Method 3: Direct Storage Assignment (What we use!)      ```solidity      users[_wallet] = User({wallet: _wallet, balance: _balance, isRegistered: true});      ```      Pros: Direct write, no intermediate copy, gas-efficient      Cons: None! This is the best approach for storage mappings      CONNECTION TO STORAGE MODEL:      Remember how mappings calculate slots? Same here!      The struct is stored starting at keccak256(_wallet, slot_7)      Each field occupies sequential slots after that.      REAL-WORLD ANALOGY:      Like a filing cabinet:      - Mapping = Drawer (organized by wallet address)      - Struct = Folder (contains related documents)      - Fields = Documents (wallet, balance, isRegistered)      GAS BREAKDOWN:      - Calculate mapping slot: ~100 gas (keccak256 computation)      - Write wallet field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Write balance field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Write isRegistered field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Event emission: ~2,000 gas      TOTAL: ~62,000 gas (cold) or ~17,000 gas (warm)      \\ud83c\\udf93 LEARNING MOMENT:      Why not use memory first? Because copying to memory then to storage      costs MORE gas! Direct assignment is always more efficient.      Memory is for temporary data, storage is for persistent data!\",\"params\":{\"_balance\":\"The initial balance\",\"_wallet\":\"The user's wallet address\"}},\"removeNumber(uint256)\":{\"details\":\"ARRAY REMOVAL: The Clever Swap Trick \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Removing from arrays is tricky! You have two approaches:      APPROACH 1: Shift Everything (Naive, Expensive)      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 [10, 20, 30, 40]                       \\u2502      \\u2502 Remove index 1 (value 20)              \\u2502      \\u2502 \\u2193                                       \\u2502      \\u2502 [10, 30, 40, 0]  \\u2190 Shift left         \\u2502      \\u2502 Cost: O(n) - must move all elements!   \\u2502      \\u2502 Gas: ~20,000+ for large arrays         \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      APPROACH 2: Swap with Last (Clever, Efficient)      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 [10, 20, 30, 40]                       \\u2502      \\u2502 Remove index 1 (value 20)              \\u2502      \\u2502 \\u2193                                       \\u2502      \\u2502 Step 1: Swap [1] with [3]              \\u2502      \\u2502 [10, 40, 30, 20]                       \\u2502      \\u2502 \\u2193                                       \\u2502      \\u2502 Step 2: Pop last element               \\u2502      \\u2502 [10, 40, 30]                           \\u2502      \\u2502 Cost: O(1) - constant time!           \\u2502      \\u2502 Gas: ~5,000 (just swap + pop)          \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: This is called the \\\"swap-and-pop\\\" pattern!      It's used in many Solidity contracts because it's gas-efficient.      The trade-off: order is not preserved, but that's often fine!      WHY IT WORKS:      Arrays don't care about order for many use cases.      If you need order, you'd use a different data structure anyway.      CONNECTION TO STORAGE:      Remember: array elements are stored at keccak256(6) + index      - Swapping: Just two storage writes (cheap!)      - Shifting: N storage writes (expensive!)      REAL-WORLD ANALOGY:      Like removing a book from a library shelf:      - Naive: Shift all books left (lots of work!)      - Clever: Swap with last book, remove last (minimal work!)      GAS COMPARISON:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Method          \\u2502 Time         \\u2502 Gas (10 el)  \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 Shift all       \\u2502 O(n)         \\u2502 ~50,000      \\u2502      \\u2502 Swap + pop      \\u2502 O(1)         \\u2502 ~5,000       \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      Savings: 90% gas reduction! \\ud83c\\udf89      \\u26a0\\ufe0f  IMPORTANT CAVEAT:      This changes the order! If order matters, use a different approach:      - Use a mapping instead of an array      - Accept the gas cost of shifting      - Use a linked list (more complex but preserves order)      \\ud83c\\udf93 LEARNING MOMENT:      This pattern shows why understanding data structures matters!      Choosing the right approach can save massive amounts of gas.      In blockchain development, gas = money, so efficiency is critical!\",\"params\":{\"_index\":\"The index of the element to remove\"}},\"setBalance(address,uint256)\":{\"details\":\"MAPPING BEHAVIOR:      - If key doesn't exist, creates new entry      - No \\\"key exists\\\" check needed      - Can't iterate over keys (no .keys() like Python)      - Can't get length/size STORAGE SLOT CALCULATION:   Slot = keccak256(abi.encodePacked(_address, 5))   where 5 is the slot of the 'balances' mapping GAS OPTIMIZATION: Direct assignment vs read-modify-write - balances[_address] = _balance: 1 SSTORE = ~20,000 gas (cold) or ~5,000 (warm) - Alternative: uint256 old = balances[_address]; balances[_address] = _balance;   Costs: 1 SLOAD + 1 SSTORE = ~7,100 gas (warm) - Direct assignment saves: ~2,100 gas (no need to read if we're overwriting) GAS: ~20,000 gas (first write to this address - cold)      ~5,000 gas (update existing balance - warm) REAL-WORLD ANALOGY: Like writing a new value in a phone book - if you're replacing the entire entry, you don't need to read it first. Just write the new value directly. LANGUAGE COMPARISON:   TypeScript: balances.set(address, balance) - similar concept   Go: balances[address] = balance - similar syntax   Rust: balances.insert(address, balance) - similar concept   Solidity: balances[address] = balance - direct assignment\",\"params\":{\"_address\":\"The address to set balance for\",\"_balance\":\"The balance amount\"}},\"setMessage(string)\":{\"details\":\"STRING STORAGE: The Expensive Choice      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550            Strings in Solidity are like luxury items - they work great, but they cost!      Unlike bytes32 (fixed 32 bytes), strings are dynamic and variable-length.      HOW STRINGS ARE STORED:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Slot N: Length (uint256)           \\u2502 \\u2190 How many bytes?      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 Slot N+1: First 32 bytes of data   \\u2502 \\u2190 UTF-8 encoded characters      \\u2502 Slot N+2: Next 32 bytes of data    \\u2502 \\u2190 Continues if > 32 chars      \\u2502 ...                                 \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: \\\"Hello World\\\" (11 chars) uses 2 slots:      - Slot 1: length = 11      - Slot 2: \\\"Hello World\\\" + padding      Total: ~40,000 gas (cold) vs bytes32's ~20,000 gas      WHY SO EXPENSIVE?      1. Length encoding overhead (extra storage slot)      2. UTF-8 encoding complexity (multi-byte characters)      3. Dynamic size means more complex storage layout      CONNECTION TO EARLIER CONCEPTS:      Remember bytes32? It's like a fixed-size box - predictable and cheap.      Strings are like expandable luggage - flexible but heavier!      REAL-WORLD ANALOGY:      bytes32 = Fixed-size shipping box (always same cost)      string = Variable-size package (costs more, scales with size)      WHEN TO USE STRINGS:      \\u2705 User-facing text (names, descriptions)      \\u2705 Dynamic content that changes length      \\u274c Don't use for: hashes, fixed identifiers, gas-critical operations      GAS BREAKDOWN:      - Reading old message: ~2,100 gas (cold) or ~100 gas (warm)      - Writing new message: ~20,000+ gas (depends on length)      - Event emission: ~2,000 gas      TOTAL: ~24,000+ gas (first call)      OPTIMIZATION TIP:      If you know max length \\u2264 32 bytes, use bytes32 instead!      Example: bytes32 public shortMessage; // Much cheaper!\",\"params\":{\"_message\":\"The new message\"}},\"setNumber(uint256)\":{\"details\":\"GAS COST BREAKDOWN:      - Function call overhead: ~21,000 gas (transaction base cost)      - SLOAD (read old value for event): ~2,100 gas (cold) or ~100 (warm)      - SSTORE (write new value): ~20,000 gas (cold) or ~5,000 (warm)      - Event emission: ~2,000 gas      TOTAL: ~45,000 gas (first call), ~28,000 gas (subsequent) GAS OPTIMIZATION: Why cache oldValue? - Reading number: 1 SLOAD = 100 gas (warm) - We use it for the event - If we read it twice: 2 SLOADs = 200 gas - Caching: 1 SLOAD + 1 MLOAD = 103 gas - Savings: ~97 gas ALTERNATIVE (less efficient):   emit NumberUpdated(number, _number);  // Reads number twice   number = _number;   This would cost more gas due to multiple storage reads WHY PUBLIC?   - Callable externally and internally   - Generates automatic getter   - Costs ~200 gas more than 'external' due to memory copying ALTERNATIVE: Could use 'external' if never called internally   - Saves ~200 gas per call   - But can't call from within contract VISIBILITY OPTIONS:   public: callable anywhere (costs ~200 gas more for arrays)   external: callable only from outside (cheaper for arrays)   internal: callable only by this contract or derived contracts   private: callable only by this contract REAL-WORLD ANALOGY: Like updating a value in a spreadsheet - you read the old value first (to log it), then write the new value. Caching the old value is like writing it on a sticky note so you don't have to look it up again.\",\"params\":{\"_number\":\"The new number value\"}},\"sumMemoryArray(uint256[])\":{\"details\":\"DATA LOCATIONS: The Three Realms of Solidity \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Solidity has THREE data locations, each with different properties:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Location    \\u2502 Persistence  \\u2502 Cost         \\u2502 Mutability   \\u2502      \\u251c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524      \\u2502 storage     \\u2502 Permanent    \\u2502 ~20k/write   \\u2502 Mutable      \\u2502      \\u2502 memory      \\u2502 Temporary    \\u2502 ~3/word      \\u2502 Mutable      \\u2502      \\u2502 calldata    \\u2502 Read-only    \\u2502 Free         \\u2502 Immutable    \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      MEMORY: The Temporary Workspace      \\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550      Memory is like a scratchpad - temporary and cheap!      - Allocated when function is called      - Erased when function exits      - Perfect for calculations and return values      HOW MEMORY WORKS:      \\u250c\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510      \\u2502 Function called                          \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Memory allocated (grows as needed)      \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Function executes (uses memory)         \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Function returns                         \\u2502      \\u2502   \\u2193                                      \\u2502      \\u2502 Memory cleared (freed automatically)     \\u2502      \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518      FUN FACT: Memory grows linearly!      Each 32-byte word costs ~3 gas to allocate.      An array of 10 uint256s costs ~30 gas for memory allocation.      Compare that to storage: ~200,000 gas for 10 writes!      CONNECTION TO STORAGE:      Remember: storage is expensive (~20k gas/write)      Memory is cheap (~3 gas/word)      That's why we use memory for temporary calculations!      REAL-WORLD ANALOGY:      - Storage = Filing cabinet (permanent, expensive to access)      - Memory = Desk workspace (temporary, cheap, easy to use)      - Calldata = Reading a letter (read-only, free)      WHY PURE?      This function is `pure` because it:      1. Doesn't read state (no SLOAD operations)      2. Doesn't write state (no SSTORE operations)      3. Only uses function parameters and local variables      PURE vs VIEW vs PAYABLE:      - pure: No state access, no ETH (most restrictive)      - view: Can read state, no ETH      - payable: Can read/write state, can receive ETH      GAS BREAKDOWN:      - Function call overhead: ~21,000 gas (if on-chain)      - Memory allocation: ~3 gas \\u00d7 array length      - Loop operations: ~3 gas \\u00d7 array length (additions)      - Return: ~3 gas \\u00d7 return size      TOTAL: ~21,000 + (6 gas \\u00d7 length) if on-chain             FREE if called off-chain (pure functions!)      \\ud83c\\udf93 LEARNING MOMENT:      Why use memory here? Because we're not storing anything!      We're just calculating a sum and returning it.      Using storage would be wasteful - we'd pay ~20k gas per write      just to read it back immediately!\",\"params\":{\"_arr\":\"Array to process (in memory)\"},\"returns\":{\"_0\":\"The sum of array elements\"}}},\"stateVariables\":{\"balances\":{\"details\":\"Stored starting at slot 5 (conceptually)      Actual storage: keccak256(abi.encodePacked(key, slot)) WHY MAPPINGS?   - O(1) lookup/insert (constant gas)   - No iteration (can't loop over keys)   - Infinite conceptual size (2^256 possible keys)   - Default value is 0 for uint, false for bool, etc. STORAGE CALCULATION:   For key 0x1234... the storage slot is:   keccak256(abi.encodePacked(0x1234..., 5)) GAS: First access (cold): ~2,100 gas      Subsequent (warm): ~100 gas PYTHON EQUIVALENT: balances = {}  (dictionary) RUST EQUIVALENT: HashMap<Address, u256>\"},\"data\":{\"details\":\"Stored in slot 3      WHY bytes32? Gas-efficient for hashes (keccak256 output)      Fixed size = predictable gas costs COMPARISON:   bytes32: Fixed, efficient, 32-byte hash/data   bytes: Dynamic, expensive, arbitrary length   string: Dynamic, UTF-8 encoded, avoid for gas efficiency\"},\"isActive\":{\"details\":\"Stored in slot 2      WHY whole slot? EVM works with 32-byte words, can't address bits GAS OPTIMIZATION: If you had multiple bools, declare them consecutively:   bool flag1; bool flag2; bool flag3;  // Still uses 32 bytes total   Better: Pack in a struct with other small types\"},\"message\":{\"details\":\"Stored starting at slot 4      Strings are dynamic and expensive - each character costs gas      Prefer bytes32 for fixed-size data when possible GAS: More expensive than bytes32 due to dynamic length encoding\"},\"number\":{\"details\":\"Stored in slot 0      WHY uint256? EVM is optimized for 256-bit words      Smaller types (uint8, uint128) cost MORE gas for arithmetic      unless used in structs for packing GAS COST: Writing this costs ~20,000 gas (first write)  REAL-WORLD ANALOGY: Like renting a storage unit - first time costs more (cold write), but accessing it later is cheaper (warm write). LANGUAGE COMPARISON:   TypeScript: let x: number = 42;  (static typing, no size concern)   Go: var x uint256 = 42  (static, explicit, size varies by platform)   Rust: let x: u256 = 42;  (static, explicit, size depends on target)   Solidity: uint256 x = 42;  (static, explicit, FIXED 256-bit size)\"},\"numbers\":{\"details\":\"Stored starting at slot 6      Length is stored in slot 6      Elements stored at: keccak256(6) + index WHY ARRAYS?   - Ordered collection   - Iterable (unlike mappings)   - Can be in storage, memory, or calldata GAS WARNING:   - push(): ~20,000+ gas (cold storage write)   - pop(): ~5,000 gas (sets last element to 0, refunds gas)   - Iterating large arrays can exceed block gas limit \\u00ef\\u00bf\\u00bd DoS BEST PRACTICE: Limit array sizes or use off-chain indexing STORAGE LAYOUT:   Slot 6: array length   Slot keccak256(6) + 0: numbers[0]   Slot keccak256(6) + 1: numbers[1]   ...\"},\"owner\":{\"details\":\"Stored in slot 1      WHY address type? Represents Ethereum accounts (EOAs) or contracts      Special type with built-in methods: .transfer(), .send(), .call() SECURITY: Always validate addresses aren't zero: address(0) NOTE: Only 20 bytes, but occupies full 32-byte slot (12 bytes wasted)       Could be packed with other variables if declared together\"},\"users\":{\"details\":\"Demonstrates nested reference types STORAGE CALCULATION (for address 0xABCD...):   Base slot: keccak256(abi.encodePacked(0xABCD..., 7))   wallet: base_slot + 0   balance: base_slot + 1   isRegistered: base_slot + 2\"}},\"title\":\"DatatypesStorageSolution\",\"version\":1},\"userdoc\":{\"events\":{\"BalanceUpdated(address,uint256)\":{\"notice\":\"Emitted when balance is updated\"},\"FundsDeposited(address,uint256)\":{\"notice\":\"Emitted when ETH is deposited\"},\"MessageUpdated(string,string)\":{\"notice\":\"Emitted when message is updated\"},\"NumberUpdated(uint256,uint256)\":{\"notice\":\"Emitted when number is updated\"},\"UserRegistered(address,uint256)\":{\"notice\":\"Emitted when a user registers\"}},\"kind\":\"user\",\"methods\":{\"addNumber(uint256)\":{\"notice\":\"Add a number to the numbers array\"},\"balances(address)\":{\"notice\":\"Mapping from address to balance\"},\"constructor\":{\"notice\":\"Initializes the contract\"},\"data()\":{\"notice\":\"Fixed-size byte array (32 bytes)\"},\"deposit()\":{\"notice\":\"Deposit ETH into the contract\"},\"getBalance(address)\":{\"notice\":\"Get balance for an address\"},\"getFirstElement(uint256[])\":{\"notice\":\"Demonstrates calldata usage - most gas-efficient for read-only\"},\"getNumber()\":{\"notice\":\"Get the number value\"},\"getNumberAt(uint256)\":{\"notice\":\"Get a number at a specific index\"},\"getNumbersLength()\":{\"notice\":\"Get the length of the numbers array\"},\"getPackedDataExample()\":{\"notice\":\"Gets packed data to demonstrate struct packing\"},\"getUser(address)\":{\"notice\":\"Get user information\"},\"hasBalance(address)\":{\"notice\":\"Check if an address has a non-zero balance\"},\"incrementNumber()\":{\"notice\":\"Increment the number by 1\"},\"isActive()\":{\"notice\":\"Boolean flag (1 bit, but uses 1 byte in storage)\"},\"message()\":{\"notice\":\"Dynamic string message\"},\"number()\":{\"notice\":\"A simple unsigned integer (256 bits / 32 bytes)\"},\"numbers(uint256)\":{\"notice\":\"Dynamic array of unsigned integers\"},\"owner()\":{\"notice\":\"Ethereum address (20 bytes)\"},\"registerUser(address,uint256)\":{\"notice\":\"Register a user\"},\"removeNumber(uint256)\":{\"notice\":\"Remove a number at a specific index from the array\"},\"setBalance(address,uint256)\":{\"notice\":\"Set balance for an address\"},\"setMessage(string)\":{\"notice\":\"Set the message string\"},\"setNumber(uint256)\":{\"notice\":\"Set the number value\"},\"sumMemoryArray(uint256[])\":{\"notice\":\"Demonstrates memory usage - processes array without persisting\"},\"users(address)\":{\"notice\":\"Mapping from address to User struct\"}},\"notice\":\"Complete reference implementation demonstrating Solidity datatypes and storage\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/solution/DatatypesStorageSolution.sol\":\"DatatypesStorageSolution\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":forge-std/=../lib/forge-std/src/\"]},\"sources\":{\"src/solution/DatatypesStorageSolution.sol\":{\"keccak256\":\"0x766c5da2f0241e99e0a48cf04fce947a3a6c6dc2e235f1d5b32d03f3b344f525\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c0f77359037fe375a7c19214dae4133c8f4cfd6ad1ff4840519f09b49c0aa200\",\"dweb:/ipfs/QmPNYyyyjXRYLK1T1octmcfbgCEuPizU1xE3av1t7pPgy9\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.20+commit.a1b79de6"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"addr","type":"address","indexed":false},{"internalType":"uint256","name":"balance","type":"uint256","indexed":false}],"type":"event","name":"BalanceUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"depositor","type":"address","indexed":true},{"internalType":"uint256","name":"amount","type":"uint256","indexed":false}],"type":"event","name":"FundsDeposited","anonymous":false},{"inputs":[{"internalType":"string","name":"oldMessage","type":"string","indexed":false},{"internalType":"string","name":"newMessage","type":"string","indexed":false}],"type":"event","name":"MessageUpdated","anonymous":false},{"inputs":[{"internalType":"uint256","name":"oldValue","type":"uint256","indexed":true},{"internalType":"uint256","name":"newValue","type":"uint256","indexed":true}],"type":"event","name":"NumberUpdated","anonymous":false},{"inputs":[{"internalType":"address","name":"wallet","type":"address","indexed":true},{"internalType":"uint256","name":"balance","type":"uint256","indexed":false}],"type":"event","name":"UserRegistered","anonymous":false},{"inputs":[{"internalType":"uint256","name":"_number","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"addNumber"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"data","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}]},{"inputs":[],"stateMutability":"payable","type":"function","name":"deposit"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"stateMutability":"view","type":"function","name":"getBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"uint256[]","name":"_arr","type":"uint256[]"}],"stateMutability":"pure","type":"function","name":"getFirstElement","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getNumber","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"stateMutability":"view","type":"function","name":"getNumberAt","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getNumbersLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getPackedDataExample","outputs":[{"internalType":"uint128","name":"","type":"uint128"},{"internalType":"uint128","name":"","type":"uint128"},{"internalType":"uint64","name":"","type":"uint64"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"_wallet","type":"address"}],"stateMutability":"view","type":"function","name":"getUser","outputs":[{"internalType":"address","name":"wallet","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"bool","name":"isRegistered","type":"bool"}]},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"stateMutability":"view","type":"function","name":"hasBalance","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"incrementNumber"},{"inputs":[],"stateMutability":"view","type":"function","name":"isActive","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"message","outputs":[{"internalType":"string","name":"","type":"string"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"number","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function","name":"numbers","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"_wallet","type":"address"},{"internalType":"uint256","name":"_balance","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"registerUser"},{"inputs":[{"internalType":"uint256","name":"_index","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"removeNumber"},{"inputs":[{"internalType":"address","name":"_address","type":"address"},{"internalType":"uint256","name":"_balance","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"setBalance"},{"inputs":[{"internalType":"string","name":"_message","type":"string"}],"stateMutability":"nonpayable","type":"function","name":"setMessage"},{"inputs":[{"internalType":"uint256","name":"_number","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"setNumber"},{"inputs":[{"internalType":"uint256[]","name":"_arr","type":"uint256[]"}],"stateMutability":"pure","type":"function","name":"sumMemoryArray","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function","name":"users","outputs":[{"internalType":"address","name":"wallet","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"bool","name":"isRegistered","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{"addNumber(uint256)":{"details":"ARRAYS: Ordered Collections with Hidden Complexity       Arrays in Solidity are like numbered shelves in a warehouse.      Each item has a position (index), and you can add items to the end.      HOW ARRAYS ARE STORED:             Slot 6: Length (how many items)              Stored separately!             Slot keccak256(6) + 0: numbers[0]            First element       Slot keccak256(6) + 1: numbers[1]            Second element       Slot keccak256(6) + 2: numbers[2]            Third element       ...                                                     FUN FACT: The length and elements are stored SEPARATELY!      This is different from languages like Python where length is calculated.      In Solidity, length is a state variable that must be updated manually.      WHAT HAPPENS WHEN YOU PUSH:      Step 1: Read current length (SLOAD: ~100 gas warm)      Step 2: Write new length = old_length + 1 (SSTORE: ~5,000 gas warm)      Step 3: Calculate new element slot = keccak256(6) + new_length      Step 4: Write element to that slot (SSTORE: ~5,000 gas warm)            TOTAL: ~10,000+ gas (warm) or ~40,000+ gas (cold)      CONNECTION TO MAPPINGS:      Notice the storage calculation? It's similar to mappings!      - Mapping: slot = keccak256(key, mapping_slot)      - Array: slot = keccak256(array_slot) + index      Both use keccak256, but arrays use sequential indices!      For our numbers array: slot = keccak256(6) + index      REAL-WORLD ANALOGY:      Think of a library:      - Length = catalog showing how many books      - Elements = actual books on numbered shelves      - push() = add a new book and update the catalog        THE DANGER: Unbounded Growth!                  Arrays can grow FOREVER (up to 2^256 elements theoretically).      This creates a Denial of Service (DoS) vulnerability:      Example Attack:      ```solidity      // Attacker calls this repeatedly      function attack() public {          for(uint i = 0; i < 1000; i++) {              addNumber(i); // Makes array huge!          }      }            // Later, this becomes impossible (exceeds gas limit)      function processAll() public {          for(uint i = 0; i < numbers.length; i++) {              // Process numbers[i]...              //  FAILS if array too large!          }      }      ```      DEFENSE PATTERNS:      1. Limit array size: require(numbers.length < MAX_SIZE)      2. Use mappings instead (O(1) access, no iteration needed)      3. Emit events, process off-chain (indexers handle the heavy lifting)      GAS OPTIMIZATION TIP:      If you know the max size upfront, use fixed-size arrays!      ```solidity      uint256[10] public fixedNumbers; // Max 10 elements, cheaper!      ```       LEARNING MOMENT:      Why is push() expensive? Because it does TWO storage writes:      1. Update the length counter      2. Write the new element      Each storage write costs ~5,000 gas (warm) or ~20,000 gas (cold)!","params":{"_number":"The number to add"}},"constructor":{"details":"Constructor runs ONCE on deployment   CONSTRUCTORS: The One-Time Setup       Constructors are special functions that run EXACTLY ONCE - when the contract is deployed.      Think of them as the \"birth\" of your contract - they set up the initial state.      HOW CONSTRUCTORS WORK:             Developer deploys contract                                                                   Constructor executes                     Runs ONCE, never again!                                                      Initial state is set                                                                          Contract is live on blockchain                                                                Constructor code is DISCARDED             Not stored!            FUN FACT: Constructor code is NOT stored on-chain!      Only the runtime code (your functions) is stored.      The constructor runs during deployment, then disappears!      This saves gas - you don't pay to store initialization code forever.      WHY SET OWNER IN CONSTRUCTOR?      This is a CRITICAL security pattern:      1. Establishes who controls the contract      2. msg.sender during deployment = the deployer      3. Prevents anyone else from claiming ownership      4. Common pattern in \"Ownable\" contracts (like OpenZeppelin)      CONNECTION TO SECURITY:      Setting owner in constructor ensures:      - Only deployer can be owner (can't be changed later)      - No race conditions (set atomically during deployment)      - Clear ownership from the start      REAL-WORLD ANALOGY:      Like setting up a new bank account:      - Constructor = Opening the account (one-time setup)      - Owner = Account holder (who controls it)      - isActive = Account status (active/inactive)      GAS COST:      - Constructor execution: Included in deployment cost      - Setting owner: ~20,000 gas (cold write)      - Setting isActive: ~20,000 gas (cold write)      - Total deployment: ~200,000+ gas (includes bytecode storage)        IMPORTANT: Constructor can't be called again!      Once deployed, there's NO WAY to re-run the constructor.      This is why initialization must be complete and correct!       LEARNING MOMENT:      Constructors are your only chance to set initial state!      Make sure everything is initialized correctly here.      If you forget something, you'll need a separate initialization function      (but that's less secure - anyone could call it!)."},"deposit()":{"details":"Payable function - receives ETH and updates balance  RECEIVING ETH: The Magic of Payable Functions       This function is SPECIAL - it can receive Ether! Notice the `payable` keyword?      Without `payable`, sending ETH to this function would REVERT.      HOW IT WORKS:             User sends transaction with ETH                                                               Contract receives ETH automatically       Magic happens here!                                                      msg.value contains the ETH amount         Accessible in function                                                      Contract balance increases                No explicit transfer needed!            FUN FACT: Before Solidity 0.6.0, you had to use `address(this).balance`      to check received ETH. Now `msg.value` makes it explicit and safer!      CONNECTION TO MAPPINGS:      We're using the `balances` mapping we learned about earlier!      This is a real-world use case: tracking user deposits.      REAL-WORLD ANALOGY:      Think of this like a vending machine:      - You insert coins (send ETH)      - Machine records your credit (updates balances mapping)      - You can check your balance anytime (getBalance())      - Machine logs the transaction (emits event)      SECURITY CONSIDERATIONS:        Always validate msg.value > 0 (prevents accidental zero deposits)        Use += instead of = to handle multiple deposits correctly        Consider reentrancy protection for production contracts      GAS BREAKDOWN:      - require() check: ~3 gas (if passes)      - Mapping read + write: ~20,000 gas (cold) or ~5,000 gas (warm)      - Event emission: ~2,000 gas      TOTAL: ~22,000 gas (first deposit) or ~7,000 gas (subsequent)      PATTERN RECOGNITION:      Notice we use `+=` here? This is read-modify-write pattern.      We MUST read first (to get existing balance), then add, then write.      This is different from setBalance() where we just overwrite!       LEARNING MOMENT:      Why `+=` instead of `=`? Because users might deposit multiple times!      If Alice deposits 1 ETH, then 2 ETH, her balance should be 3 ETH total.      Using `=` would overwrite and lose the first deposit! "},"getBalance(address)":{"details":"MAPPING DEFAULT VALUES: The Zero Mystery       Here's something fascinating about Solidity mappings:      They ALWAYS return a value, even for keys that were never set!      THE ZERO DEFAULT:             Key never set?  Returns 0           Not an error!       Key set to 0?    Returns 0           Same result!            FUN FACT: This is different from most languages!      - Python: Raises KeyError if key doesn't exist      - JavaScript: Returns undefined      - Solidity: Returns the type's default value (0 for uint256)      WHY THIS DESIGN?      Solidity prioritizes gas efficiency and safety:      1. No need to check \"does key exist?\" (saves gas)      2. No risk of undefined/null errors (safer)      3. Predictable behavior (easier to reason about)      THE PROBLEM: Can't Distinguish States                  How do you know if someone has zero balance because:      A) They never deposited (key doesn't exist)      B) They deposited and withdrew everything (key exists, value is 0)      SOLUTION PATTERNS:            Pattern 1: Separate existence mapping      ```solidity      mapping(address => bool) public hasDeposited;      mapping(address => uint256) public balances;            function deposit() public payable {          hasDeposited[msg.sender] = true;  // Mark as existing          balances[msg.sender] += msg.value;      }      ```      Pattern 2: Use non-zero sentinel value      ```solidity      // Reserve 0 for \"never set\", use 1 wei minimum for \"exists\"      ```      CONNECTION TO STORAGE:      Remember how mappings calculate storage slots?      slot = keccak256(key, mapping_slot)      If that slot was never written to, it contains all zeros!      That's why we get 0 back - it's literally reading empty storage!      REAL-WORLD ANALOGY:      Like checking a mailbox:      - Empty mailbox (never used) = 0 letters      - Mailbox with 0 letters (all removed) = 0 letters      You can't tell which is which just by looking!      GAS COST:      - Cold read: ~2,100 gas (first time accessing this address)      - Warm read: ~100 gas (subsequent reads)      - No gas if called off-chain (view functions are free when called externally)       LEARNING MOMENT:      This is why `hasBalance()` exists! It's a helper that checks if balance > 0.      But remember: balance = 0 doesn't mean \"never set\" - it could mean \"withdrawn everything\"!","params":{"_address":"The address to query"},"returns":{"_0":"The balance amount"}},"getFirstElement(uint256[])":{"details":"CALLDATA: The Zero-Copy Champion!       Calldata is the MOST gas-efficient data location!      It's read-only data that comes directly from the transaction.      HOW CALLDATA WORKS:             User sends transaction with data                                                              Data stored in transaction calldata      Already on-chain!                                                      Function reads directly from calldata     No copy needed!                                                      Function returns                                     FUN FACT: Calldata is part of the transaction itself!      When you call a function, the parameters are encoded in the transaction.      Calldata lets you read directly from that transaction data - zero copy!      THE THREE DATA LOCATIONS COMPARED:            Storage (Most Expensive):      - Cost: ~20,000 gas/write, ~100 gas/read (warm)      - Use: Persistent state      - Example: State variables      Memory (Medium Cost):      - Cost: ~3 gas/word allocation      - Use: Temporary calculations      - Example: Local variables, return values      Calldata (Cheapest!):      - Cost: ~100 gas (just reading, no allocation)      - Use: Function parameters (external functions)      - Example: Arrays/strings passed to external functions      CONNECTION TO GAS OPTIMIZATION:      Remember: gas = money on Ethereum!      Using calldata instead of memory can save thousands of gas.      For a 100-element array:      - Memory: ~300 gas (copy 100 words  3 gas)      - Calldata: ~100 gas (just read, no copy)      Savings: 200 gas per call!      REAL-WORLD ANALOGY:      - Storage = Filing cabinet (expensive to access)      - Memory = Photocopying a document (costs money)      - Calldata = Reading the original document (free!)        RESTRICTIONS:      - Only available in EXTERNAL functions      - Cannot be modified (read-only)      - Cannot be used in internal/public functions      WHY EXTERNAL?      External functions are more gas-efficient than public:      - Public: Can be called internally (requires memory copy)      - External: Only callable externally (can use calldata)      - Trade-off: Can't call from within contract (use this.functionName())      GAS COMPARISON (100-element array):             Location     Allocation   Read First El                calldata     0 gas        ~100 gas          Winner!       memory       ~300 gas     ~103 gas               storage      N/A          ~100 gas                     LEARNING MOMENT:      Always use calldata for arrays/strings in external functions!      It's the most gas-efficient option and makes your intent clear.      Only use memory if you need to modify the data.","params":{"_arr":"Array to process (in calldata)"},"returns":{"_0":"The first element"}},"getNumber()":{"details":"VIEW FUNCTIONS: Reading State Without Cost       View functions are special - they can read state but not modify it.      When called off-chain, they're FREE! No gas cost at all!      HOW VIEW FUNCTIONS WORK:             Off-chain call (e.g., from frontend)                                                           Function executes locally                  No transaction!                                                      Reads state (simulated)                    Free!                                                      Returns value                                        FUN FACT: View functions don't create transactions!      They're executed locally by your node, then the result is returned.      This is why they're free - nothing is written to the blockchain!      WHEN DO VIEW FUNCTIONS COST GAS?      Only when called by another contract (on-chain call):      - Contract A calls Contract B's view function      - This happens in a transaction      - Gas is charged (~100 gas for SLOAD)      CONNECTION TO AUTOMATIC GETTERS:      Remember: `public uint256 number;` automatically creates a getter!      Solidity generates `function number() public view returns (uint256)`      So why write this explicit function?      - Demonstrates the concept      - Can add custom logic later      - Shows how view functions work      REAL-WORLD ANALOGY:      Like checking your bank balance:      - Off-chain: Look at your phone app (free, instant)      - On-chain: Bank teller checks computer (costs time/money)      GAS COST:      - Off-chain call: FREE! (no transaction)      - On-chain call: ~100 gas (SLOAD from storage)       LEARNING MOMENT:      View functions are perfect for frontends!      You can call them as many times as you want without paying gas.      This is why DApps can show real-time data - they're constantly      calling view functions to update the UI!","returns":{"_0":"The current number value"}},"getNumberAt(uint256)":{"details":"ARRAY ACCESS: Bounds Checking is Your Friend       Accessing array elements requires bounds checking.      Solidity does this automatically, but explicit checks are clearer!      HOW IT WORKS:             1. Check: Is _index < numbers.length?     Our explicit check           No  REVERT with error message                 Yes  Continue                                   2. Calculate slot:                                 slot = keccak256(6) + _index                       3. Read from storage (SLOAD)                       Return the value                                   FUN FACT: Solidity 0.8.0+ has automatic bounds checking!      Even without our require(), accessing numbers[_index] where _index >= length      would revert automatically. But explicit checks are better because:      1. Clearer error messages (\"Index out of bounds\" vs generic panic)      2. More gas-efficient (our check happens before slot calculation)      3. Better developer experience      THE STORAGE CALCULATION:      Remember: array elements are stored at keccak256(base_slot) + index      For our numbers array (slot 6):      - numbers[0]  slot = keccak256(6) + 0      - numbers[1]  slot = keccak256(6) + 1      - numbers[2]  slot = keccak256(6) + 2      CONNECTION TO MAPPINGS:      Arrays and mappings both use keccak256 for storage calculation!      - Mapping: keccak256(key, mapping_slot)      - Array: keccak256(array_slot) + index      The difference: arrays use sequential indices, mappings use arbitrary keys      LANGUAGE COMPARISON:             Language     Behavior on out-of-bounds                 C            Undefined behavior (danger!)        Python       Raises IndexError                    JavaScript   Returns undefined                   Solidity     Reverts transaction (safe!)              REAL-WORLD ANALOGY:      Like asking for book #1000 in a library with only 100 books:      - C: Gives you garbage data (undefined behavior)      - Python: Throws an error (IndexError)      - Solidity: Stops everything, refunds gas (revert)      GAS COST:      - require() check: ~3 gas (if passes)      - Storage read: ~2,100 gas (cold) or ~100 gas (warm)      TOTAL: ~2,103 gas (cold) or ~103 gas (warm)       LEARNING MOMENT:      Why check bounds explicitly? Because it's cheaper!      If we don't check and Solidity's automatic check triggers,      we've already wasted gas calculating the storage slot.      Our explicit check prevents that waste!","params":{"_index":"The index to query"},"returns":{"_0":"The number at that index"}},"getNumbersLength()":{"details":"ARRAY LENGTH: A Stored Counter       Unlike many languages, Solidity arrays store their length explicitly!      This is a design choice that prioritizes gas efficiency.      HOW IT WORKS:             Slot 6: numbers.length = 3         Stored as uint256            FUN FACT: In Python, len(array) calculates length by counting elements.      In Solidity, .length just reads a stored value - much faster!      WHY STORE IT?      1. O(1) access time (constant, not linear)      2. No need to iterate to count elements      3. Prevents out-of-bounds errors (can check before access)      CONNECTION TO STORAGE MODEL:      Remember: length is stored in slot 6 (the array's base slot)      Elements are stored starting at keccak256(6) + index      This separation allows O(1) length access!      REAL-WORLD ANALOGY:      Like a library catalog:      - Python: Count books by walking through shelves (O(n))      - Solidity: Check the catalog card (O(1))      GAS COST:      - Cold read: ~2,100 gas (first access)      - Warm read: ~100 gas (subsequent reads)      - Free if called off-chain (view functions)       LEARNING MOMENT:      This is why checking `if (index < numbers.length)` is safe!      The length is always up-to-date because push() and pop() update it automatically.","returns":{"_0":"The array length"}},"getPackedDataExample()":{"details":"This is just a view function to show that PackedData struct exists      In real usage, you'd store PackedData in a mapping or array EXAMPLE USAGE:   mapping(uint256 => PackedData) public packedDataStore;   function storePackedData(uint256 id) public {       packedDataStore[id] = PackedData({           smallNumber1: 100,           smallNumber2: 200,           timestamp: uint64(block.timestamp),           user: msg.sender,           flag: true       });   } GAS SAVINGS:   Without packing: 4 slots  20,000 gas = 80,000 gas   With packing: 2 slots  20,000 gas = 40,000 gas   SAVINGS: 50% reduction!"},"getUser(address)":{"details":"MULTIPLE RETURN VALUES: Solidity's Superpower!       Solidity functions can return MULTIPLE values - like Python tuples!      This is incredibly useful and makes code cleaner.      HOW IT WORKS:             Function returns 3 values:                       (address, uint256, bool)                                                                    Caller receives all 3 values                     (wallet, balance, status) = getUser()            FUN FACT: Named returns are a Solidity feature!      You can name the return values in the function signature,      and then just assign to them instead of using return!      EXAMPLE WITH NAMED RETURNS:      ```solidity      function getUser(address _wallet)          public view          returns (address wallet, uint256 balance, bool isRegistered)      {          wallet = users[_wallet].wallet;  // Just assign!          balance = users[_wallet].balance;          isRegistered = users[_wallet].isRegistered;          // No return statement needed!      }      ```      DATA LOCATION: Storage vs Memory            When reading structs from mappings, you have two choices:      Option 1: Storage Reference (Cheaper, but Read-Only)      ```solidity      User storage user = users[_wallet];      // user is a REFERENCE to storage      // Can't modify (would need special syntax)      ```      Option 2: Memory Copy (What we use!)      ```solidity      User memory user = users[_wallet];      // user is a COPY in memory      // Safe to read, can modify copy (doesn't affect storage)      ```      WHY MEMORY HERE?      1. We're returning values - memory is perfect for this      2. Clear intent: we're reading, not modifying      3. Slightly more gas (copying), but safer and clearer      CONNECTION TO EARLIER CONCEPTS:      Remember storage vs memory vs calldata?      - Storage: Persistent, expensive (~20k gas/write)      - Memory: Temporary, cheap (~3 gas/word)      - Calldata: Read-only, cheapest (no copy)      REAL-WORLD ANALOGY:      Like photocopying a document:      - Storage reference = Pointing to original (cheap, but can't modify)      - Memory copy = Photocopy (costs a bit, but safe to modify)      GAS COST:      - Read wallet: ~2,100 gas (cold) or ~100 gas (warm)      - Read balance: ~2,100 gas (cold) or ~100 gas (warm)      - Read isRegistered: ~2,100 gas (cold) or ~100 gas (warm)      - Copy to memory: ~9 gas (3 words  3 gas)      TOTAL: ~6,309 gas (cold) or ~309 gas (warm)       LEARNING MOMENT:      Why copy to memory? Because we're returning the values!      Return values must be in memory (or calldata for external functions).      This is a Solidity requirement - you can't return storage references!","params":{"_wallet":"The user's wallet address"},"returns":{"balance":"amount","isRegistered":"status","wallet":"address"}},"hasBalance(address)":{"details":"HELPER FUNCTIONS: Making Code More Readable       Helper functions are like shortcuts - they make code cleaner and easier to understand.      Instead of writing `balances[_address] > 0` everywhere, we create a helper!      THE MAPPING ZERO PROBLEM:            Remember the \"zero default\" behavior we learned about?      Mappings always return 0 for non-existent keys.      This creates an ambiguity:             balances[alice] = 0                                                                                  Does this mean:                                     A) Alice never deposited?                          B) Alice deposited and withdrew all?                                                                We can't tell! Both return 0!                          WHAT THIS FUNCTION DOES:      This function checks if balance > 0.      It's a simple check, but it's useful because:      1. More readable than `balances[_address] > 0`      2. Can be extended later (add more checks)      3. Documents intent clearly      CONNECTION TO EARLIER CONCEPTS:      This uses the mapping we learned about earlier!      We're reading from `balances` mapping and checking the value.      Simple, but demonstrates how concepts connect!      REAL-WORLD ANALOGY:      Like checking if a bank account has money:      - Balance = 0  No money (but was it ever used?)      - Balance > 0  Definitely has money!      BETTER PATTERN FOR EXISTENCE:      If you need to distinguish \"never set\" from \"set to 0\":      ```solidity      mapping(address => bool) public hasDeposited;      mapping(address => uint256) public balances;            function deposit() public payable {          hasDeposited[msg.sender] = true;  // Mark as existing          balances[msg.sender] += msg.value;      }            function hasBalance(address addr) public view returns (bool) {          return hasDeposited[addr] && balances[addr] > 0;      }      ```      GAS COST:      - Mapping read: ~2,100 gas (cold) or ~100 gas (warm)      - Comparison (> 0): ~3 gas      TOTAL: ~2,103 gas (cold) or ~103 gas (warm)       LEARNING MOMENT:      Helper functions make code more maintainable!      If you need to change the logic later (e.g., add minimum balance check),      you only change it in one place. This is the DRY principle:      Don't Repeat Yourself!","params":{"_address":"The address to check"},"returns":{"_0":"true if balance > 0"}},"incrementNumber()":{"details":"SOLIDITY 0.8.0+ SAFETY:      If number == type(uint256).max, this reverts automatically      Pre-0.8.0: Would silently wrap to 0 (overflow) GAS OPTIMIZATION: Why use += instead of separate operations? - number += 1: 1 SLOAD + 1 SSTORE = ~5,100 gas (warm) - Alternative: uint256 temp = number; temp += 1; number = temp;   Costs: 1 SLOAD + 1 MLOAD + 1 ADD + 1 SSTORE = ~5,103 gas - Savings: Minimal (~3 gas), but += is cleaner GAS: ~5,000 gas if slot is warm (already accessed) ALTERNATIVE PATTERNS:   unchecked { number += 1; }  // Disable overflow check, save ~100 gas   But DANGEROUS if overflow is possible!   Only use unchecked when you're CERTAIN overflow can't happen REAL-WORLD ANALOGY: Like incrementing a counter - you read the current value, add 1, and write it back. Using += does this in one operation."},"registerUser(address,uint256)":{"details":"STRUCTS: Custom Types That Group Related Data       Structs are like custom containers that group related data together.      Think of them as \"mini-objects\" or \"records\" in other languages.      HOW STRUCTS ARE STORED IN MAPPINGS:             Mapping slot calculation:                          base_slot = keccak256(_wallet, mapping_slot)             base_slot + 0: wallet (address)              20 bytes, uses full slot       base_slot + 1: balance (uint256)             32 bytes       base_slot + 2: isRegistered (bool)           1 byte, uses full slot            Total: 3 storage slots per User struct      FUN FACT: Structs in mappings are stored sequentially!      Unlike arrays where elements are at keccak256(slot) + index,      struct fields are at base_slot + field_offset.      This makes struct access predictable and efficient!      THREE WAYS TO CREATE STRUCTS:            Method 1: Named Fields (Most Readable)       ```solidity      User({wallet: _wallet, balance: _balance, isRegistered: true})      ```      Pros: Self-documenting, order doesn't matter      Cons: More verbose      Method 2: Positional (Concise)      ```solidity      User(_wallet, _balance, true)      ```      Pros: Shorter      Cons: Must remember field order, less readable      Method 3: Direct Storage Assignment (What we use!)      ```solidity      users[_wallet] = User({wallet: _wallet, balance: _balance, isRegistered: true});      ```      Pros: Direct write, no intermediate copy, gas-efficient      Cons: None! This is the best approach for storage mappings      CONNECTION TO STORAGE MODEL:      Remember how mappings calculate slots? Same here!      The struct is stored starting at keccak256(_wallet, slot_7)      Each field occupies sequential slots after that.      REAL-WORLD ANALOGY:      Like a filing cabinet:      - Mapping = Drawer (organized by wallet address)      - Struct = Folder (contains related documents)      - Fields = Documents (wallet, balance, isRegistered)      GAS BREAKDOWN:      - Calculate mapping slot: ~100 gas (keccak256 computation)      - Write wallet field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Write balance field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Write isRegistered field: ~20,000 gas (cold) or ~5,000 gas (warm)      - Event emission: ~2,000 gas      TOTAL: ~62,000 gas (cold) or ~17,000 gas (warm)       LEARNING MOMENT:      Why not use memory first? Because copying to memory then to storage      costs MORE gas! Direct assignment is always more efficient.      Memory is for temporary data, storage is for persistent data!","params":{"_balance":"The initial balance","_wallet":"The user's wallet address"}},"removeNumber(uint256)":{"details":"ARRAY REMOVAL: The Clever Swap Trick       Removing from arrays is tricky! You have two approaches:      APPROACH 1: Shift Everything (Naive, Expensive)             [10, 20, 30, 40]                              Remove index 1 (value 20)                                                                   [10, 30, 40, 0]   Shift left                Cost: O(n) - must move all elements!          Gas: ~20,000+ for large arrays                     APPROACH 2: Swap with Last (Clever, Efficient)             [10, 20, 30, 40]                              Remove index 1 (value 20)                                                                   Step 1: Swap [1] with [3]                     [10, 40, 30, 20]                                                                            Step 2: Pop last element                      [10, 40, 30]                                  Cost: O(1) - constant time!                  Gas: ~5,000 (just swap + pop)                      FUN FACT: This is called the \"swap-and-pop\" pattern!      It's used in many Solidity contracts because it's gas-efficient.      The trade-off: order is not preserved, but that's often fine!      WHY IT WORKS:      Arrays don't care about order for many use cases.      If you need order, you'd use a different data structure anyway.      CONNECTION TO STORAGE:      Remember: array elements are stored at keccak256(6) + index      - Swapping: Just two storage writes (cheap!)      - Shifting: N storage writes (expensive!)      REAL-WORLD ANALOGY:      Like removing a book from a library shelf:      - Naive: Shift all books left (lots of work!)      - Clever: Swap with last book, remove last (minimal work!)      GAS COMPARISON:             Method           Time          Gas (10 el)               Shift all        O(n)          ~50,000             Swap + pop       O(1)          ~5,000                   Savings: 90% gas reduction!         IMPORTANT CAVEAT:      This changes the order! If order matters, use a different approach:      - Use a mapping instead of an array      - Accept the gas cost of shifting      - Use a linked list (more complex but preserves order)       LEARNING MOMENT:      This pattern shows why understanding data structures matters!      Choosing the right approach can save massive amounts of gas.      In blockchain development, gas = money, so efficiency is critical!","params":{"_index":"The index of the element to remove"}},"setBalance(address,uint256)":{"details":"MAPPING BEHAVIOR:      - If key doesn't exist, creates new entry      - No \"key exists\" check needed      - Can't iterate over keys (no .keys() like Python)      - Can't get length/size STORAGE SLOT CALCULATION:   Slot = keccak256(abi.encodePacked(_address, 5))   where 5 is the slot of the 'balances' mapping GAS OPTIMIZATION: Direct assignment vs read-modify-write - balances[_address] = _balance: 1 SSTORE = ~20,000 gas (cold) or ~5,000 (warm) - Alternative: uint256 old = balances[_address]; balances[_address] = _balance;   Costs: 1 SLOAD + 1 SSTORE = ~7,100 gas (warm) - Direct assignment saves: ~2,100 gas (no need to read if we're overwriting) GAS: ~20,000 gas (first write to this address - cold)      ~5,000 gas (update existing balance - warm) REAL-WORLD ANALOGY: Like writing a new value in a phone book - if you're replacing the entire entry, you don't need to read it first. Just write the new value directly. LANGUAGE COMPARISON:   TypeScript: balances.set(address, balance) - similar concept   Go: balances[address] = balance - similar syntax   Rust: balances.insert(address, balance) - similar concept   Solidity: balances[address] = balance - direct assignment","params":{"_address":"The address to set balance for","_balance":"The balance amount"}},"setMessage(string)":{"details":"STRING STORAGE: The Expensive Choice                  Strings in Solidity are like luxury items - they work great, but they cost!      Unlike bytes32 (fixed 32 bytes), strings are dynamic and variable-length.      HOW STRINGS ARE STORED:             Slot N: Length (uint256)             How many bytes?             Slot N+1: First 32 bytes of data     UTF-8 encoded characters       Slot N+2: Next 32 bytes of data      Continues if > 32 chars       ...                                             FUN FACT: \"Hello World\" (11 chars) uses 2 slots:      - Slot 1: length = 11      - Slot 2: \"Hello World\" + padding      Total: ~40,000 gas (cold) vs bytes32's ~20,000 gas      WHY SO EXPENSIVE?      1. Length encoding overhead (extra storage slot)      2. UTF-8 encoding complexity (multi-byte characters)      3. Dynamic size means more complex storage layout      CONNECTION TO EARLIER CONCEPTS:      Remember bytes32? It's like a fixed-size box - predictable and cheap.      Strings are like expandable luggage - flexible but heavier!      REAL-WORLD ANALOGY:      bytes32 = Fixed-size shipping box (always same cost)      string = Variable-size package (costs more, scales with size)      WHEN TO USE STRINGS:       User-facing text (names, descriptions)       Dynamic content that changes length       Don't use for: hashes, fixed identifiers, gas-critical operations      GAS BREAKDOWN:      - Reading old message: ~2,100 gas (cold) or ~100 gas (warm)      - Writing new message: ~20,000+ gas (depends on length)      - Event emission: ~2,000 gas      TOTAL: ~24,000+ gas (first call)      OPTIMIZATION TIP:      If you know max length  32 bytes, use bytes32 instead!      Example: bytes32 public shortMessage; // Much cheaper!","params":{"_message":"The new message"}},"setNumber(uint256)":{"details":"GAS COST BREAKDOWN:      - Function call overhead: ~21,000 gas (transaction base cost)      - SLOAD (read old value for event): ~2,100 gas (cold) or ~100 (warm)      - SSTORE (write new value): ~20,000 gas (cold) or ~5,000 (warm)      - Event emission: ~2,000 gas      TOTAL: ~45,000 gas (first call), ~28,000 gas (subsequent) GAS OPTIMIZATION: Why cache oldValue? - Reading number: 1 SLOAD = 100 gas (warm) - We use it for the event - If we read it twice: 2 SLOADs = 200 gas - Caching: 1 SLOAD + 1 MLOAD = 103 gas - Savings: ~97 gas ALTERNATIVE (less efficient):   emit NumberUpdated(number, _number);  // Reads number twice   number = _number;   This would cost more gas due to multiple storage reads WHY PUBLIC?   - Callable externally and internally   - Generates automatic getter   - Costs ~200 gas more than 'external' due to memory copying ALTERNATIVE: Could use 'external' if never called internally   - Saves ~200 gas per call   - But can't call from within contract VISIBILITY OPTIONS:   public: callable anywhere (costs ~200 gas more for arrays)   external: callable only from outside (cheaper for arrays)   internal: callable only by this contract or derived contracts   private: callable only by this contract REAL-WORLD ANALOGY: Like updating a value in a spreadsheet - you read the old value first (to log it), then write the new value. Caching the old value is like writing it on a sticky note so you don't have to look it up again.","params":{"_number":"The new number value"}},"sumMemoryArray(uint256[])":{"details":"DATA LOCATIONS: The Three Realms of Solidity       Solidity has THREE data locations, each with different properties:             Location     Persistence   Cost          Mutability                storage      Permanent     ~20k/write    Mutable             memory       Temporary     ~3/word       Mutable             calldata     Read-only     Free          Immutable                MEMORY: The Temporary Workspace            Memory is like a scratchpad - temporary and cheap!      - Allocated when function is called      - Erased when function exits      - Perfect for calculations and return values      HOW MEMORY WORKS:             Function called                                                                                Memory allocated (grows as needed)                                                            Function executes (uses memory)                                                               Function returns                                                                               Memory cleared (freed automatically)                 FUN FACT: Memory grows linearly!      Each 32-byte word costs ~3 gas to allocate.      An array of 10 uint256s costs ~30 gas for memory allocation.      Compare that to storage: ~200,000 gas for 10 writes!      CONNECTION TO STORAGE:      Remember: storage is expensive (~20k gas/write)      Memory is cheap (~3 gas/word)      That's why we use memory for temporary calculations!      REAL-WORLD ANALOGY:      - Storage = Filing cabinet (permanent, expensive to access)      - Memory = Desk workspace (temporary, cheap, easy to use)      - Calldata = Reading a letter (read-only, free)      WHY PURE?      This function is `pure` because it:      1. Doesn't read state (no SLOAD operations)      2. Doesn't write state (no SSTORE operations)      3. Only uses function parameters and local variables      PURE vs VIEW vs PAYABLE:      - pure: No state access, no ETH (most restrictive)      - view: Can read state, no ETH      - payable: Can read/write state, can receive ETH      GAS BREAKDOWN:      - Function call overhead: ~21,000 gas (if on-chain)      - Memory allocation: ~3 gas  array length      - Loop operations: ~3 gas  array length (additions)      - Return: ~3 gas  return size      TOTAL: ~21,000 + (6 gas  length) if on-chain             FREE if called off-chain (pure functions!)       LEARNING MOMENT:      Why use memory here? Because we're not storing anything!      We're just calculating a sum and returning it.      Using storage would be wasteful - we'd pay ~20k gas per write      just to read it back immediately!","params":{"_arr":"Array to process (in memory)"},"returns":{"_0":"The sum of array elements"}}},"version":1},"userdoc":{"kind":"user","methods":{"addNumber(uint256)":{"notice":"Add a number to the numbers array"},"balances(address)":{"notice":"Mapping from address to balance"},"constructor":{"notice":"Initializes the contract"},"data()":{"notice":"Fixed-size byte array (32 bytes)"},"deposit()":{"notice":"Deposit ETH into the contract"},"getBalance(address)":{"notice":"Get balance for an address"},"getFirstElement(uint256[])":{"notice":"Demonstrates calldata usage - most gas-efficient for read-only"},"getNumber()":{"notice":"Get the number value"},"getNumberAt(uint256)":{"notice":"Get a number at a specific index"},"getNumbersLength()":{"notice":"Get the length of the numbers array"},"getPackedDataExample()":{"notice":"Gets packed data to demonstrate struct packing"},"getUser(address)":{"notice":"Get user information"},"hasBalance(address)":{"notice":"Check if an address has a non-zero balance"},"incrementNumber()":{"notice":"Increment the number by 1"},"isActive()":{"notice":"Boolean flag (1 bit, but uses 1 byte in storage)"},"message()":{"notice":"Dynamic string message"},"number()":{"notice":"A simple unsigned integer (256 bits / 32 bytes)"},"numbers(uint256)":{"notice":"Dynamic array of unsigned integers"},"owner()":{"notice":"Ethereum address (20 bytes)"},"registerUser(address,uint256)":{"notice":"Register a user"},"removeNumber(uint256)":{"notice":"Remove a number at a specific index from the array"},"setBalance(address,uint256)":{"notice":"Set balance for an address"},"setMessage(string)":{"notice":"Set the message string"},"setNumber(uint256)":{"notice":"Set the number value"},"sumMemoryArray(uint256[])":{"notice":"Demonstrates memory usage - processes array without persisting"},"users(address)":{"notice":"Mapping from address to User struct"}},"version":1}},"settings":{"remappings":["forge-std/=../lib/forge-std/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/solution/DatatypesStorageSolution.sol":"DatatypesStorageSolution"},"evmVersion":"shanghai","libraries":{}},"sources":{"src/solution/DatatypesStorageSolution.sol":{"keccak256":"0x766c5da2f0241e99e0a48cf04fce947a3a6c6dc2e235f1d5b32d03f3b344f525","urls":["bzz-raw://c0f77359037fe375a7c19214dae4133c8f4cfd6ad1ff4840519f09b49c0aa200","dweb:/ipfs/QmPNYyyyjXRYLK1T1octmcfbgCEuPizU1xE3av1t7pPgy9"],"license":"MIT"}},"version":1},"id":38}